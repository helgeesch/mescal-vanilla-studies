
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://docs.mesqual.io/mescal-package-documentation/api_reference/energy_data_handling/area_accounting/model_gen/">
      
      
        <link rel="prev" href="../">
      
      
        <link rel="next" href="../area_variables/">
      
      
      <link rel="icon" href="../../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.19">
    
    
      
        <title>Area / Border Model Generators - MESCAL Suite Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../../../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="amber">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#area-and-areaborder-model-df-generators" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../../.." title="MESCAL Suite Documentation" class="md-header__button md-logo" aria-label="MESCAL Suite Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            MESCAL Suite Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Area / Border Model Generators
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/helgeesch/mescal-vanilla-studies/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../../.." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    
    
      
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../../study_manager/" class="md-tabs__link">
          
  
  
  MESCAL API Reference

        </a>
      </li>
    
  

    
  

      
        
  
  
  
  
    
    
      
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../../mescal-study-01/notebooks/mescal_101_study_manager_and_basic_fetching/" class="md-tabs__link">
          
  
  
  Studies & Examples

        </a>
      </li>
    
  

    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="MESCAL Suite Documentation" class="md-nav__button md-logo" aria-label="MESCAL Suite Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    MESCAL Suite Documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/helgeesch/mescal-vanilla-studies/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    MESCAL API Reference
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            MESCAL API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Core
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            Core
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../study_manager/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    StudyManager
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../datasets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Datasets
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_3" >
        
          
          <label class="md-nav__link" for="__nav_2_1_3" id="__nav_2_1_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Flag System
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_3">
            <span class="md-nav__icon md-icon"></span>
            Flag System
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../flag/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Flag
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../flag_index/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    FlagIndex
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../units/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Units
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../validation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Validation
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../visualization/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    Visualization Modules
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_2" id="__nav_2_2_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            Visualization Modules
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/time_series_dashboard/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    TimeSeriesDashboard
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../visualization/folium_viz_system/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    Folium Viz System
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_2_2" id="__nav_2_2_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2">
            <span class="md-nav__icon md-icon"></span>
            Folium Viz System
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/areas/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Areas
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/circle_marker/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Circle Marker
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/text_overlay/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Text Overlay
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/lines/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lines
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/line_text_overlay/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Line Text Overlay
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/arrow_icon/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Arrow Icon
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2_7" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2_7" id="__nav_2_2_2_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Base
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_2_2_2_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2_7">
            <span class="md-nav__icon md-icon"></span>
            Base
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/system/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Abstract System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/data_item/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Data Item
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_viz_system/kpi_collection/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    KPI Collection Visualizer
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/folium_legend_system/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Folium Legend System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/html_table/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    HTML Table
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../visualization/html_dashboard/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    HTML Dashboard
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" checked>
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    Energy Data Handling
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_3" id="__nav_2_3_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            Energy Data Handling
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3_1" checked>
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    Area Accounting
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_3_1" id="__nav_2_3_1_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_3_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_3_1">
            <span class="md-nav__icon md-icon"></span>
            Area Accounting
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Area / Border Model Generators
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Area / Border Model Generators
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator" class="md-nav__link">
    <span class="md-ellipsis">
      AreaModelGenerator
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AreaModelGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.generate_base_area_model_from_area_names_in_node_model_df" class="md-nav__link">
    <span class="md-ellipsis">
      generate_base_area_model_from_area_names_in_node_model_df
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.ensure_completeness_of_area_model_df" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_completeness_of_area_model_df
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_area_model_df_by_adding_node_count_per_area" class="md-nav__link">
    <span class="md-ellipsis">
      enhance_area_model_df_by_adding_node_count_per_area
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_area_model_df_by_adding_representative_geo_point" class="md-nav__link">
    <span class="md-ellipsis">
      enhance_area_model_df_by_adding_representative_geo_point
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.generate_area_model" class="md-nav__link">
    <span class="md-ellipsis">
      generate_area_model
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_with_geometry" class="md-nav__link">
    <span class="md-ellipsis">
      enhance_with_geometry
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions" class="md-nav__link">
    <span class="md-ellipsis">
      AreaBorderNamingConventions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AreaBorderNamingConventions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_area_border_name" class="md-nav__link">
    <span class="md-ellipsis">
      get_area_border_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.decompose_area_border_name_to_areas" class="md-nav__link">
    <span class="md-ellipsis">
      decompose_area_border_name_to_areas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_opposite_area_border_name" class="md-nav__link">
    <span class="md-ellipsis">
      get_opposite_area_border_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_alphabetically_sorted_border" class="md-nav__link">
    <span class="md-ellipsis">
      get_alphabetically_sorted_border
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator" class="md-nav__link">
    <span class="md-ellipsis">
      AreaBorderModelGenerator
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AreaBorderModelGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.generate_area_border_model" class="md-nav__link">
    <span class="md-ellipsis">
      generate_area_border_model
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.get_area_graph" class="md-nav__link">
    <span class="md-ellipsis">
      get_area_graph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.enhance_with_geometry" class="md-nav__link">
    <span class="md-ellipsis">
      enhance_with_geometry
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator" class="md-nav__link">
    <span class="md-ellipsis">
      AreaBorderGeometryCalculator
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AreaBorderGeometryCalculator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.calculate_border_geometry" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_border_geometry
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.areas_touch" class="md-nav__link">
    <span class="md-ellipsis">
      areas_touch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.areas_intersect" class="md-nav__link">
    <span class="md-ellipsis">
      areas_intersect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_area_border_midpoint_and_angle" class="md-nav__link">
    <span class="md-ellipsis">
      get_area_border_midpoint_and_angle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_area_geometry" class="md-nav__link">
    <span class="md-ellipsis">
      get_area_geometry
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_straight_line_between_areas" class="md-nav__link">
    <span class="md-ellipsis">
      get_straight_line_between_areas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder" class="md-nav__link">
    <span class="md-ellipsis">
      NonCrossingPathFinder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="NonCrossingPathFinder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.find_shortest_path" class="md-nav__link">
    <span class="md-ellipsis">
      find_shortest_path
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase" class="md-nav__link">
    <span class="md-ellipsis">
      GeoModelGeneratorBase
    </span>
  </a>
  
    <nav class="md-nav" aria-label="GeoModelGeneratorBase">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase.get_representative_area_point" class="md-nav__link">
    <span class="md-ellipsis">
      get_representative_area_point
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../area_variables/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Area Variables
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../border_variables/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Border Variables
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3_2" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../model_handling/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    Model Membership Handling
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_3_2" id="__nav_2_3_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3_2">
            <span class="md-nav__icon md-icon"></span>
            Model Membership Handling
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../model_handling/property_enricher/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Property Enricher
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../model_handling/pairs_appender/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Pairs Appender
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3_3" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../variable_utils/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    Variable Utils
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_3_3" id="__nav_2_3_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3_3">
            <span class="md-nav__icon md-icon"></span>
            Variable Utils
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../variable_utils/in_common_aggs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    In-common Aggregations
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../variable_utils/direction_aggs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Up-/Down Directional Aggregations
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../variable_utils/congestion_rent/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Congestion Rent
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../variable_utils/regional_trade_balance/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Regional Trade Balance
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../granularity_modules/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Granularity Modules
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../network_lines_data/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Network Lines Data
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../time_series_gap_handling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Time Series Gap Handling
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
          
          
        
      
    
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Utils
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4">
            <span class="md-nav__icon md-icon"></span>
            Utils
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4_1" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../utils/pandas_utils/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    pandas_utils
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_4_1" id="__nav_2_4_1_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4_1">
            <span class="md-nav__icon md-icon"></span>
            pandas_utils
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/pandas_utils/flatten_df/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Flatten DF
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/pandas_utils/pend_props/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Pend Properties
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/pandas_utils/filter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Filter by Model
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/pandas_utils/xs_df/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    xs DF
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/pandas_utils/sort_multiindex/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Sort MultiIndex
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/pandas_utils/merge_multi_index_levels/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Merge MultiIndex Levels
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/pandas_utils/set_new_column/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Set New Column in MultiIndex
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/pandas_utils/combine_dfs.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Combine DFs
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4_2" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../utils/plotly_utils/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    plotly_utils
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_4_2" id="__nav_2_4_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_4_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4_2">
            <span class="md-nav__icon md-icon"></span>
            plotly_utils
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/plotly_utils/plotly_theme/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PlotlyTheme
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/plotly_utils/figure_utils/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    figure_utils
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../utils/plotly_utils/px_category_utils/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    px_category_utils
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Studies & Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Studies & Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Intro to MESCAL
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            Intro to MESCAL
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_101_study_manager_and_basic_fetching/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 101: StudyManager and Dataset Fundamentals
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_102_mastering_data_fetching/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 102: Advanced Data Fetching Techniques
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_103_scenario_attributes/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 103: Scenario Attributes
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_301_time_series_dashboard/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 301: Time Series Dashboard
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_302_segmented_colormap/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 302: Segmented Colormap
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_303_folium_model_df_map/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 401: Folium Model Data Visualization - Areas, Points, and Lines
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_304_folium_area_kpi_map/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 402: Folium KPI Visualization System
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_304_simple_area_kpi_map/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 303: Interactive Geospatial with Folium
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_307_country_plotter_util/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 307: Country Plotter Utility Module
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../mescal-study-01/notebooks/mescal_308_html_dashboards/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    MESCAL 305: HTML Dashboard Utility
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator" class="md-nav__link">
    <span class="md-ellipsis">
      AreaModelGenerator
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AreaModelGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.generate_base_area_model_from_area_names_in_node_model_df" class="md-nav__link">
    <span class="md-ellipsis">
      generate_base_area_model_from_area_names_in_node_model_df
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.ensure_completeness_of_area_model_df" class="md-nav__link">
    <span class="md-ellipsis">
      ensure_completeness_of_area_model_df
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_area_model_df_by_adding_node_count_per_area" class="md-nav__link">
    <span class="md-ellipsis">
      enhance_area_model_df_by_adding_node_count_per_area
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_area_model_df_by_adding_representative_geo_point" class="md-nav__link">
    <span class="md-ellipsis">
      enhance_area_model_df_by_adding_representative_geo_point
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.generate_area_model" class="md-nav__link">
    <span class="md-ellipsis">
      generate_area_model
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_with_geometry" class="md-nav__link">
    <span class="md-ellipsis">
      enhance_with_geometry
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions" class="md-nav__link">
    <span class="md-ellipsis">
      AreaBorderNamingConventions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AreaBorderNamingConventions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_area_border_name" class="md-nav__link">
    <span class="md-ellipsis">
      get_area_border_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.decompose_area_border_name_to_areas" class="md-nav__link">
    <span class="md-ellipsis">
      decompose_area_border_name_to_areas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_opposite_area_border_name" class="md-nav__link">
    <span class="md-ellipsis">
      get_opposite_area_border_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_alphabetically_sorted_border" class="md-nav__link">
    <span class="md-ellipsis">
      get_alphabetically_sorted_border
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator" class="md-nav__link">
    <span class="md-ellipsis">
      AreaBorderModelGenerator
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AreaBorderModelGenerator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.generate_area_border_model" class="md-nav__link">
    <span class="md-ellipsis">
      generate_area_border_model
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.get_area_graph" class="md-nav__link">
    <span class="md-ellipsis">
      get_area_graph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.enhance_with_geometry" class="md-nav__link">
    <span class="md-ellipsis">
      enhance_with_geometry
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator" class="md-nav__link">
    <span class="md-ellipsis">
      AreaBorderGeometryCalculator
    </span>
  </a>
  
    <nav class="md-nav" aria-label="AreaBorderGeometryCalculator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.calculate_border_geometry" class="md-nav__link">
    <span class="md-ellipsis">
      calculate_border_geometry
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.areas_touch" class="md-nav__link">
    <span class="md-ellipsis">
      areas_touch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.areas_intersect" class="md-nav__link">
    <span class="md-ellipsis">
      areas_intersect
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_area_border_midpoint_and_angle" class="md-nav__link">
    <span class="md-ellipsis">
      get_area_border_midpoint_and_angle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_area_geometry" class="md-nav__link">
    <span class="md-ellipsis">
      get_area_geometry
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_straight_line_between_areas" class="md-nav__link">
    <span class="md-ellipsis">
      get_straight_line_between_areas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder" class="md-nav__link">
    <span class="md-ellipsis">
      NonCrossingPathFinder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="NonCrossingPathFinder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.find_shortest_path" class="md-nav__link">
    <span class="md-ellipsis">
      find_shortest_path
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase" class="md-nav__link">
    <span class="md-ellipsis">
      GeoModelGeneratorBase
    </span>
  </a>
  
    <nav class="md-nav" aria-label="GeoModelGeneratorBase">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase.get_representative_area_point" class="md-nav__link">
    <span class="md-ellipsis">
      get_representative_area_point
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="area-and-areaborder-model-df-generators">Area and AreaBorder Model-DF Generators<a class="headerlink" href="#area-and-areaborder-model-df-generators" title="Permanent link">&para;</a></h1>


<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">AreaModelGenerator</span>


<a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="            GeoModelGeneratorBase (mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase)" href="#mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase">GeoModelGeneratorBase</a></code></p>


        <p>Generates comprehensive area model DataFrames from node-to-area mappings.</p>
<p>This class creates detailed area model DataFrames that aggregate node-level data
into area-level representations for energy system analysis. It supports
automatic area discovery, node counting, and geographic representative point
calculation for visualization and spatial analysis.</p>
<p>The generator processes node model data with area assignments to create
comprehensive area models suitable for energy system aggregation, market
analysis, and spatial visualization workflows.</p>


<details class="key-features" open>
  <summary>Key Features</summary>
  <ul>
<li>Automatic area discovery from node-to-area mappings</li>
<li>Representative geographic point calculation for visualization</li>
<li>Integration with geometric area data (polygons, boundaries)</li>
<li>Support for different area granularities (countries, bidding zones, regions)</li>
<li>Robust handling of missing or incomplete area assignments</li>
</ul>
</details>

<details class="mescal-integration" open>
  <summary>MESCAL Integration</summary>
  <p>Designed to work with MESCAL's area accounting system, providing
area model building capabilities that support spatial energy system analysis,
capacity aggregation, and visualization workflows.</p>
</details>

<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.node_model_df">node_model_df</span></code></td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Node-level data with area assignments</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.area_column">area_column</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name containing area identifiers</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.geo_location_column">geo_location_column</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name containing geographic Point objects</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Examples:</p>
<div class="highlight"><pre><span></span><code>Basic area model generation:
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from shapely.geometry import Point
&gt;&gt;&gt;
&gt;&gt;&gt; # Create node model with area assignments
&gt;&gt;&gt; node_data = pd.DataFrame({
&gt;&gt;&gt;     &#39;voltage&#39;: [380, 380, 220, 380, 220],
&gt;&gt;&gt;     &#39;country&#39;: [&#39;DE&#39;, &#39;DE&#39;, &#39;FR&#39;, &#39;FR&#39;, &#39;BE&#39;],
&gt;&gt;&gt;     &#39;capacity_mw&#39;: [2000, 1500, 800, 1200, 600],
&gt;&gt;&gt;     &#39;location&#39;: [Point(10, 52), Point(11, 53), Point(2, 48),
&gt;&gt;&gt;                  Point(3, 49), Point(4, 50)]
&gt;&gt;&gt; }, index=[&#39;DE1&#39;, &#39;DE2&#39;, &#39;FR1&#39;, &#39;FR2&#39;, &#39;BE1&#39;])
&gt;&gt;&gt;
&gt;&gt;&gt; # Generate area model
&gt;&gt;&gt; generator = AreaModelGenerator(node_data, &#39;country&#39;)
&gt;&gt;&gt; area_model = generator.generate_area_model()
&gt;&gt;&gt; print(area_model)
              node_count projection_point
    country
    DE               2    POINT (10.5 52.5)
    FR               2    POINT (2.5 48.5)
    BE               1    POINT (4 50)

Enhanced area model with geometry:
&gt;&gt;&gt; import geopandas as gpd
&gt;&gt;&gt; from shapely.geometry import Polygon
&gt;&gt;&gt;
&gt;&gt;&gt; # Create area geometries
&gt;&gt;&gt; area_polygons = gpd.GeoDataFrame({
&gt;&gt;&gt;     &#39;geometry&#39;: [
&gt;&gt;&gt;         Polygon([(9, 51), (12, 51), (12, 54), (9, 54)]),  # DE
&gt;&gt;&gt;         Polygon([(1, 47), (4, 47), (4, 50), (1, 50)]),   # FR
&gt;&gt;&gt;         Polygon([(3, 49), (5, 49), (5, 51), (3, 51)])    # BE
&gt;&gt;&gt;     ]
&gt;&gt;&gt; }, index=[&#39;DE&#39;, &#39;FR&#39;, &#39;BE&#39;])
&gt;&gt;&gt;
&gt;&gt;&gt; # Enhance with geometry
&gt;&gt;&gt; area_model_geo = generator.enhance_with_geometry(area_model, area_polygons)
&gt;&gt;&gt; print(f&quot;Enhanced model has geometry: {&#39;geometry&#39; in area_model_geo.columns}&quot;)

Custom enhancement workflow:
&gt;&gt;&gt; # Step-by-step area model building
&gt;&gt;&gt; base_model = generator.generate_base_area_model_from_area_names_in_node_model_df()
&gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_node_count_per_area(base_model)
&gt;&gt;&gt; final_model = generator.enhance_area_model_df_by_adding_representative_geo_point(enhanced_model)
&gt;&gt;&gt; print(f&quot;Created area model with {len(final_model)} areas&quot;)
</code></pre></div>


<details class="energy-domain-context" open>
  <summary>Energy Domain Context</summary>
  <ul>
<li>Area models are fundamental for energy system analysis, enabling:<ul>
<li>Projection of node-level data to area-level data (e.g. nodal prices -&gt; area prices)</li>
<li>Market zone aggregation and analysis</li>
<li>Regional energy balance studies</li>
<li>...</li>
</ul>
</li>
</ul>
</details>







              <details class="quote">
                <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/area_model_generator.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AreaModelGenerator</span><span class="p">(</span><span class="n">GeoModelGeneratorBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates comprehensive area model DataFrames from node-to-area mappings.</span>

<span class="sd">    This class creates detailed area model DataFrames that aggregate node-level data</span>
<span class="sd">    into area-level representations for energy system analysis. It supports</span>
<span class="sd">    automatic area discovery, node counting, and geographic representative point</span>
<span class="sd">    calculation for visualization and spatial analysis.</span>

<span class="sd">    The generator processes node model data with area assignments to create</span>
<span class="sd">    comprehensive area models suitable for energy system aggregation, market</span>
<span class="sd">    analysis, and spatial visualization workflows.</span>

<span class="sd">    Key Features:</span>
<span class="sd">        - Automatic area discovery from node-to-area mappings</span>
<span class="sd">        - Representative geographic point calculation for visualization</span>
<span class="sd">        - Integration with geometric area data (polygons, boundaries)</span>
<span class="sd">        - Support for different area granularities (countries, bidding zones, regions)</span>
<span class="sd">        - Robust handling of missing or incomplete area assignments</span>

<span class="sd">    MESCAL Integration:</span>
<span class="sd">        Designed to work with MESCAL&#39;s area accounting system, providing</span>
<span class="sd">        area model building capabilities that support spatial energy system analysis,</span>
<span class="sd">        capacity aggregation, and visualization workflows.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        node_model_df (pd.DataFrame): Node-level data with area assignments</span>
<span class="sd">        area_column (str): Column name containing area identifiers</span>
<span class="sd">        geo_location_column (str): Column name containing geographic Point objects</span>

<span class="sd">    Examples:</span>

<span class="sd">        Basic area model generation:</span>
<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create node model with area assignments</span>
<span class="sd">        &gt;&gt;&gt; node_data = pd.DataFrame({</span>
<span class="sd">        &gt;&gt;&gt;     &#39;voltage&#39;: [380, 380, 220, 380, 220],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;country&#39;: [&#39;DE&#39;, &#39;DE&#39;, &#39;FR&#39;, &#39;FR&#39;, &#39;BE&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;capacity_mw&#39;: [2000, 1500, 800, 1200, 600],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;location&#39;: [Point(10, 52), Point(11, 53), Point(2, 48),</span>
<span class="sd">        &gt;&gt;&gt;                  Point(3, 49), Point(4, 50)]</span>
<span class="sd">        &gt;&gt;&gt; }, index=[&#39;DE1&#39;, &#39;DE2&#39;, &#39;FR1&#39;, &#39;FR2&#39;, &#39;BE1&#39;])</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Generate area model</span>
<span class="sd">        &gt;&gt;&gt; generator = AreaModelGenerator(node_data, &#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; area_model = generator.generate_area_model()</span>
<span class="sd">        &gt;&gt;&gt; print(area_model)</span>
<span class="sd">                      node_count projection_point</span>
<span class="sd">            country</span>
<span class="sd">            DE               2    POINT (10.5 52.5)</span>
<span class="sd">            FR               2    POINT (2.5 48.5)</span>
<span class="sd">            BE               1    POINT (4 50)</span>

<span class="sd">        Enhanced area model with geometry:</span>
<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create area geometries</span>
<span class="sd">        &gt;&gt;&gt; area_polygons = gpd.GeoDataFrame({</span>
<span class="sd">        &gt;&gt;&gt;     &#39;geometry&#39;: [</span>
<span class="sd">        &gt;&gt;&gt;         Polygon([(9, 51), (12, 51), (12, 54), (9, 54)]),  # DE</span>
<span class="sd">        &gt;&gt;&gt;         Polygon([(1, 47), (4, 47), (4, 50), (1, 50)]),   # FR</span>
<span class="sd">        &gt;&gt;&gt;         Polygon([(3, 49), (5, 49), (5, 51), (3, 51)])    # BE</span>
<span class="sd">        &gt;&gt;&gt;     ]</span>
<span class="sd">        &gt;&gt;&gt; }, index=[&#39;DE&#39;, &#39;FR&#39;, &#39;BE&#39;])</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Enhance with geometry</span>
<span class="sd">        &gt;&gt;&gt; area_model_geo = generator.enhance_with_geometry(area_model, area_polygons)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Enhanced model has geometry: {&#39;geometry&#39; in area_model_geo.columns}&quot;)</span>

<span class="sd">        Custom enhancement workflow:</span>
<span class="sd">        &gt;&gt;&gt; # Step-by-step area model building</span>
<span class="sd">        &gt;&gt;&gt; base_model = generator.generate_base_area_model_from_area_names_in_node_model_df()</span>
<span class="sd">        &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_node_count_per_area(base_model)</span>
<span class="sd">        &gt;&gt;&gt; final_model = generator.enhance_area_model_df_by_adding_representative_geo_point(enhanced_model)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Created area model with {len(final_model)} areas&quot;)</span>

<span class="sd">    Energy Domain Context:</span>
<span class="sd">        - Area models are fundamental for energy system analysis, enabling:</span>
<span class="sd">            - Projection of node-level data to area-level data (e.g. nodal prices -&gt; area prices)</span>
<span class="sd">            - Market zone aggregation and analysis</span>
<span class="sd">            - Regional energy balance studies</span>
<span class="sd">            - ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">node_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">area_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">geo_location_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the area model generator.</span>

<span class="sd">        Args:</span>
<span class="sd">            node_model_df: DataFrame containing node-level data with area assignments.</span>
<span class="sd">                Must contain area_column with area identifiers for each node.</span>
<span class="sd">                May contain geographic Point objects for spatial analysis.</span>
<span class="sd">            area_column: Column name in node_model_df containing area assignments</span>
<span class="sd">                (e.g., &#39;country&#39;, &#39;bidding_zone&#39;, &#39;market_region&#39;, &#39;control_area&#39;).</span>
<span class="sd">            geo_location_column: Column name containing geographic Point objects</span>
<span class="sd">                for representative point calculation. If None, automatically</span>
<span class="sd">                detects column containing Point geometries.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If area_column is not found in node_model_df columns.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">            &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Node data with area assignments</span>
<span class="sd">            &gt;&gt;&gt; nodes = pd.DataFrame({</span>
<span class="sd">            &gt;&gt;&gt;     &#39;voltage_kv&#39;: [380, 220, 380, 150],</span>
<span class="sd">            &gt;&gt;&gt;     &#39;country&#39;: [&#39;DE&#39;, &#39;DE&#39;, &#39;FR&#39;, &#39;FR&#39;], </span>
<span class="sd">            &gt;&gt;&gt;     &#39;bidding_zone&#39;: [&#39;DE_LU&#39;, &#39;DE_LU&#39;, &#39;FR&#39;, &#39;FR&#39;],</span>
<span class="sd">            &gt;&gt;&gt;     &#39;coordinates&#39;: [Point(10, 52), Point(11, 53), Point(2, 48), Point(3, 49)]</span>
<span class="sd">            &gt;&gt;&gt; }, index=[&#39;DE1&#39;, &#39;DE2&#39;, &#39;FR1&#39;, &#39;FR2&#39;])</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Initialize for country-level analysis</span>
<span class="sd">            &gt;&gt;&gt; generator = AreaModelGenerator(nodes, &#39;country&#39;, &#39;coordinates&#39;)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Or let it auto-detect geographic column</span>
<span class="sd">            &gt;&gt;&gt; generator = AreaModelGenerator(nodes, &#39;bidding_zone&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span> <span class="o">=</span> <span class="n">node_model_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_column</span> <span class="o">=</span> <span class="n">area_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geo_location_column</span> <span class="o">=</span> <span class="n">geo_location_column</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_geo_location_column</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_inputs</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Area column &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="si">}</span><span class="s2">&#39; not found in node_model_df. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available columns: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_identify_geo_location_column</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Point</span><span class="p">)</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">c</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_base_area_model_from_area_names_in_node_model_df</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate base area model DataFrame from unique area names in node data.</span>

<span class="sd">        Creates a minimal area model DataFrame containing only the unique area</span>
<span class="sd">        identifiers found in the node model data. This forms the foundation</span>
<span class="sd">        for building comprehensive area models.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Base area model with area identifiers as index.</span>
<span class="sd">                Contains no additional columns - serves as starting point</span>
<span class="sd">                for enhancement with node counts, geographic data, etc.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; generator = AreaModelGenerator(node_data, &#39;country&#39;)</span>
<span class="sd">            &gt;&gt;&gt; base_model = generator.generate_base_area_model_from_area_names_in_node_model_df()</span>
<span class="sd">            &gt;&gt;&gt; print(base_model)</span>
<span class="sd">                Empty DataFrame</span>
<span class="sd">                Columns: []</span>
<span class="sd">                Index: [&#39;DE&#39;, &#39;FR&#39;, &#39;BE&#39;]</span>

<span class="sd">        Note:</span>
<span class="sd">            Areas with None or NaN values in the area_column are excluded</span>
<span class="sd">            from the generated model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unique_areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">area_model_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">unique_areas</span><span class="p">)</span>
        <span class="n">area_model_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_column</span>
        <span class="k">return</span> <span class="n">area_model_df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ensure_completeness_of_area_model_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure area model contains all areas present in node data.</span>

<span class="sd">        Validates and extends an existing area model DataFrame to include</span>
<span class="sd">        any areas found in the node data that might be missing from the</span>
<span class="sd">        provided area model. This is useful when working with predefined</span>
<span class="sd">        area models that may not cover all areas in the dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_model_df: Existing area model DataFrame to validate and extend.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Complete area model containing all areas from node data.</span>
<span class="sd">                Existing data is preserved, new areas are added with NaN values</span>
<span class="sd">                for existing columns.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; # Predefined area model missing some areas</span>
<span class="sd">            &gt;&gt;&gt; partial_model = pd.DataFrame({</span>
<span class="sd">            &gt;&gt;&gt;     &#39;max_price&#39;: [5000, 3000]</span>
<span class="sd">            &gt;&gt;&gt; }, index=[&#39;DE&#39;, &#39;FR&#39;])</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Ensure completeness (adds &#39;BE&#39; if present in node data)</span>
<span class="sd">            &gt;&gt;&gt; complete_model = generator.ensure_completeness_of_area_model_df(partial_model)</span>
<span class="sd">            &gt;&gt;&gt; print(complete_model)</span>
<span class="sd">                          max_price</span>
<span class="sd">                country</span>
<span class="sd">                DE             5000</span>
<span class="sd">                FR             3000</span>
<span class="sd">                BE              NaN</span>

<span class="sd">        Use Case:</span>
<span class="sd">            Essential for maintaining data consistency when combining</span>
<span class="sd">            predefined area models with dynamic node-based area discovery.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">complete_set</span> <span class="o">=</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">complete_set</span><span class="p">:</span>
                <span class="n">complete_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">complete_set</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">enhance_area_model_df_by_adding_node_count_per_area</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">area_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">node_count_column_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;node_count&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enhance area model by adding node count statistics per area.</span>

<span class="sd">        Aggregates the number of nodes assigned to each area and adds this</span>
<span class="sd">        information to the area model DataFrame. Node counts are essential</span>
<span class="sd">        for understanding infrastructure density and capacity distribution.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_model_df: Base area model DataFrame to enhance.</span>
<span class="sd">            node_count_column_name: Name for the new node count column.</span>
<span class="sd">                Defaults to &#39;node_count&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Enhanced area model with node count column added.</span>
<span class="sd">                Existing data is preserved, node counts are added for all areas.</span>
<span class="sd">                Areas not present in node data will have NaN node counts.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; base_model = generator.generate_base_area_model_from_area_names_in_node_model_df()</span>
<span class="sd">            &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_node_count_per_area(base_model)</span>
<span class="sd">            &gt;&gt;&gt; print(enhanced_model)</span>
<span class="sd">                          node_count</span>
<span class="sd">                country</span>
<span class="sd">                DE               2</span>
<span class="sd">                FR               2</span>
<span class="sd">                BE               1</span>

<span class="sd">            &gt;&gt;&gt; # Custom column name</span>
<span class="sd">            &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_node_count_per_area(</span>
<span class="sd">            &gt;&gt;&gt;     base_model, &#39;infrastructure_count&#39;</span>
<span class="sd">            &gt;&gt;&gt; )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">node_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">node_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="n">node_count_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
        <span class="k">return</span> <span class="n">enhanced_df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">enhance_area_model_df_by_adding_representative_geo_point</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">area_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
            <span class="n">target_column_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;projection_point&#39;</span><span class="p">,</span>
            <span class="n">round_point_decimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enhance area model by adding representative geographic points for</span>
<span class="sd">        labeling and KPI printing in map visualizations.</span>

<span class="sd">        Calculates representative geographic points for each area based on</span>
<span class="sd">        either area geometries (if available) or node locations within each area.</span>
<span class="sd">        These points are useful for visualization, labeling, and spatial analysis.</span>

<span class="sd">        The method supports two calculation modes:</span>
<span class="sd">        1. Geometry-based: Uses area polygon centroids or representative points</span>
<span class="sd">        2. Node-based: Calculates centroid from node locations within each area</span>

<span class="sd">        Args:</span>
<span class="sd">            area_model_df: Area model DataFrame to enhance. Can be regular DataFrame</span>
<span class="sd">                or GeoDataFrame with &#39;geometry&#39; column.</span>
<span class="sd">            target_column_name: Name for the new representative point column.</span>
<span class="sd">                Defaults to &#39;projection_point&#39;.</span>
<span class="sd">            round_point_decimals: Number of decimal places for coordinate rounding.</span>
<span class="sd">                Set to None to disable rounding. Defaults to 4.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Enhanced area model with representative points added.</span>
<span class="sd">                Points are added as Shapely Point objects suitable for mapping</span>
<span class="sd">                and spatial analysis.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If geo_location_column contains non-Point objects.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; # Node-based representative points</span>
<span class="sd">            &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_representative_geo_point(base_model)</span>
<span class="sd">            &gt;&gt;&gt; print(enhanced_model)</span>
<span class="sd">                          projection_point</span>
<span class="sd">                country</span>
<span class="sd">                DE        POINT (10.5 52.5)</span>
<span class="sd">                FR        POINT (2.5 48.5)</span>
<span class="sd">                BE        POINT (4 50)</span>

<span class="sd">            &gt;&gt;&gt; # With custom column name and precision</span>
<span class="sd">            &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_representative_geo_point(</span>
<span class="sd">            &gt;&gt;&gt;     base_model, &#39;center_point&#39;, round_point_decimals=2</span>
<span class="sd">            &gt;&gt;&gt; )</span>

<span class="sd">            &gt;&gt;&gt; # Access coordinates for mapping</span>
<span class="sd">            &gt;&gt;&gt; center = enhanced_model.loc[&#39;DE&#39;, &#39;projection_point&#39;]</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;DE center: {center.x:.2f}, {center.y:.2f}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">round_point</span><span class="p">(</span><span class="n">point</span><span class="p">:</span> <span class="n">Point</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Point</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">round_point_decimals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">point</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">point</span><span class="p">)(</span><span class="nb">round</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">round_point_decimals</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">round_point_decimals</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">target_column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="p">:</span>
            <span class="n">enhanced_df</span><span class="p">[</span><span class="n">target_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">geo</span> <span class="o">=</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">geo</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geo</span><span class="p">,</span> <span class="p">(</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">)):</span>
                    <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">round_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representative_area_point</span><span class="p">(</span><span class="n">geo</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_location_column</span><span class="p">:</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">area</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_location_column</span><span class="p">]</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">locations</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Point</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">locations</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Geographic location column &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_location_column</span><span class="si">}</span><span class="s1">&quot; must contain only &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;Point objects. Found: </span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">locations</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="p">)]</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="p">)</span>
                    <span class="n">representative_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_representative_point_from_cloud_of_2d_points</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
                    <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">round_point</span><span class="p">(</span><span class="n">representative_point</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">enhanced_df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_area_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate complete area model with node counts and representative points.</span>

<span class="sd">        Creates a comprehensive area model DataFrame by combining base area</span>
<span class="sd">        discovery, node count aggregation, and representative geographic point</span>
<span class="sd">        calculation. This is the main method for generating complete area models.</span>

<span class="sd">        The generated model includes:</span>
<span class="sd">            - All unique areas from node data</span>
<span class="sd">            - Node count per area for capacity/infrastructure analysis</span>
<span class="sd">            - Representative geographic points for visualization</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Complete area model with node counts and geographic data.</span>
<span class="sd">                Index contains area identifiers, columns include &#39;node_count&#39;</span>
<span class="sd">                and &#39;projection_point&#39; (if geographic data available).</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; generator = AreaModelGenerator(node_data, &#39;country&#39;)</span>
<span class="sd">            &gt;&gt;&gt; area_model = generator.generate_area_model()</span>
<span class="sd">            &gt;&gt;&gt; print(area_model)</span>
<span class="sd">                          node_count projection_point</span>
<span class="sd">                country</span>
<span class="sd">                DE               2    POINT (10.5 52.5)</span>
<span class="sd">                FR               2    POINT (2.5 48.5)</span>
<span class="sd">                BE               1    POINT (4 50)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">area_model_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_base_area_model_from_area_names_in_node_model_df</span><span class="p">()</span>
        <span class="n">area_model_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enhance_area_model_df_by_adding_node_count_per_area</span><span class="p">(</span><span class="n">area_model_df</span><span class="p">)</span>
        <span class="n">area_model_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enhance_area_model_df_by_adding_representative_geo_point</span><span class="p">(</span><span class="n">area_model_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">area_model_df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">enhance_with_geometry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">area_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">area_gdf</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enhance area model with geometric polygon data for spatial analysis.</span>

<span class="sd">        Integrates area polygon geometries from a GeoDataFrame into the area model,</span>
<span class="sd">        enabling advanced spatial analysis, visualization, and border calculations.</span>
<span class="sd">        The method matches areas by index and creates a proper GeoDataFrame output.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_model_df: Area model DataFrame to enhance with geometry.</span>
<span class="sd">            area_gdf: GeoDataFrame containing area polygon geometries.</span>
<span class="sd">                Must have &#39;geometry&#39; column with Polygon or MultiPolygon objects.</span>
<span class="sd">                Areas are matched by index values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            gpd.GeoDataFrame: Enhanced area model as GeoDataFrame with geometry column.</span>
<span class="sd">                All original data is preserved, geometry column is added for areas</span>
<span class="sd">                that exist in both DataFrames. Missing geometries are set to None.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">            &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Create area geometries</span>
<span class="sd">            &gt;&gt;&gt; area_polygons = gpd.GeoDataFrame({</span>
<span class="sd">            &gt;&gt;&gt;     &#39;area_name&#39;: [&#39;Germany&#39;, &#39;France&#39;, &#39;Belgium&#39;],</span>
<span class="sd">            &gt;&gt;&gt;     &#39;geometry&#39;: [</span>
<span class="sd">            &gt;&gt;&gt;         Polygon([(9, 51), (12, 51), (12, 54), (9, 54)]),</span>
<span class="sd">            &gt;&gt;&gt;         Polygon([(1, 47), (4, 47), (4, 50), (1, 50)]),</span>
<span class="sd">            &gt;&gt;&gt;         Polygon([(3, 49), (5, 49), (5, 51), (3, 51)])</span>
<span class="sd">            &gt;&gt;&gt;     ]</span>
<span class="sd">            &gt;&gt;&gt; }, index=[&#39;DE&#39;, &#39;FR&#39;, &#39;BE&#39;])</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Enhance area model with geometry</span>
<span class="sd">            &gt;&gt;&gt; geo_model = generator.enhance_with_geometry(area_model, area_polygons)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Model has geometry: {isinstance(geo_model, gpd.GeoDataFrame)}&quot;)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Use for spatial operations</span>
<span class="sd">            &gt;&gt;&gt; total_area = geo_model[&#39;geometry&#39;].area.sum()</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Total area: {total_area:.0f} square units&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">enhanced_df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">area_gdf</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enhanced_df</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
            <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">enhanced_df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">enhanced_df</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.__init__" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">__init__</span>


<a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.__init__" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">__init__</span><span class="p">(</span><span class="n">node_model_df</span><span class="p">:</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span><span class="p">,</span> <span class="n">area_column</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">geo_location_column</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Initialize the area model generator.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>node_model_df</code>
            </td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>DataFrame containing node-level data with area assignments.
Must contain area_column with area identifiers for each node.
May contain geographic Point objects for spatial analysis.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_column</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name in node_model_df containing area assignments
(e.g., 'country', 'bidding_zone', 'market_region', 'control_area').</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>geo_location_column</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name containing geographic Point objects
for representative point calculation. If None, automatically
detects column containing Point geometries.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If area_column is not found in node_model_df columns.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from shapely.geometry import Point
&gt;&gt;&gt; 
&gt;&gt;&gt; # Node data with area assignments
&gt;&gt;&gt; nodes = pd.DataFrame({
&gt;&gt;&gt;     &#39;voltage_kv&#39;: [380, 220, 380, 150],
&gt;&gt;&gt;     &#39;country&#39;: [&#39;DE&#39;, &#39;DE&#39;, &#39;FR&#39;, &#39;FR&#39;], 
&gt;&gt;&gt;     &#39;bidding_zone&#39;: [&#39;DE_LU&#39;, &#39;DE_LU&#39;, &#39;FR&#39;, &#39;FR&#39;],
&gt;&gt;&gt;     &#39;coordinates&#39;: [Point(10, 52), Point(11, 53), Point(2, 48), Point(3, 49)]
&gt;&gt;&gt; }, index=[&#39;DE1&#39;, &#39;DE2&#39;, &#39;FR1&#39;, &#39;FR2&#39;])
&gt;&gt;&gt; 
&gt;&gt;&gt; # Initialize for country-level analysis
&gt;&gt;&gt; generator = AreaModelGenerator(nodes, &#39;country&#39;, &#39;coordinates&#39;)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Or let it auto-detect geographic column
&gt;&gt;&gt; generator = AreaModelGenerator(nodes, &#39;bidding_zone&#39;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/area_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">area_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">geo_location_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the area model generator.</span>

<span class="sd">    Args:</span>
<span class="sd">        node_model_df: DataFrame containing node-level data with area assignments.</span>
<span class="sd">            Must contain area_column with area identifiers for each node.</span>
<span class="sd">            May contain geographic Point objects for spatial analysis.</span>
<span class="sd">        area_column: Column name in node_model_df containing area assignments</span>
<span class="sd">            (e.g., &#39;country&#39;, &#39;bidding_zone&#39;, &#39;market_region&#39;, &#39;control_area&#39;).</span>
<span class="sd">        geo_location_column: Column name containing geographic Point objects</span>
<span class="sd">            for representative point calculation. If None, automatically</span>
<span class="sd">            detects column containing Point geometries.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If area_column is not found in node_model_df columns.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Node data with area assignments</span>
<span class="sd">        &gt;&gt;&gt; nodes = pd.DataFrame({</span>
<span class="sd">        &gt;&gt;&gt;     &#39;voltage_kv&#39;: [380, 220, 380, 150],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;country&#39;: [&#39;DE&#39;, &#39;DE&#39;, &#39;FR&#39;, &#39;FR&#39;], </span>
<span class="sd">        &gt;&gt;&gt;     &#39;bidding_zone&#39;: [&#39;DE_LU&#39;, &#39;DE_LU&#39;, &#39;FR&#39;, &#39;FR&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;coordinates&#39;: [Point(10, 52), Point(11, 53), Point(2, 48), Point(3, 49)]</span>
<span class="sd">        &gt;&gt;&gt; }, index=[&#39;DE1&#39;, &#39;DE2&#39;, &#39;FR1&#39;, &#39;FR2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Initialize for country-level analysis</span>
<span class="sd">        &gt;&gt;&gt; generator = AreaModelGenerator(nodes, &#39;country&#39;, &#39;coordinates&#39;)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Or let it auto-detect geographic column</span>
<span class="sd">        &gt;&gt;&gt; generator = AreaModelGenerator(nodes, &#39;bidding_zone&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span> <span class="o">=</span> <span class="n">node_model_df</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">area_column</span> <span class="o">=</span> <span class="n">area_column</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">geo_location_column</span> <span class="o">=</span> <span class="n">geo_location_column</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_geo_location_column</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_validate_inputs</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.generate_base_area_model_from_area_names_in_node_model_df" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">generate_base_area_model_from_area_names_in_node_model_df</span>


<a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.generate_base_area_model_from_area_names_in_node_model_df" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">generate_base_area_model_from_area_names_in_node_model_df</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate base area model DataFrame from unique area names in node data.</p>
<p>Creates a minimal area model DataFrame containing only the unique area
identifiers found in the node model data. This forms the foundation
for building comprehensive area models.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pd.DataFrame: Base area model with area identifiers as index.
Contains no additional columns - serves as starting point
for enhancement with node counts, geographic data, etc.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; generator = AreaModelGenerator(node_data, &#39;country&#39;)
&gt;&gt;&gt; base_model = generator.generate_base_area_model_from_area_names_in_node_model_df()
&gt;&gt;&gt; print(base_model)
    Empty DataFrame
    Columns: []
    Index: [&#39;DE&#39;, &#39;FR&#39;, &#39;BE&#39;]
</code></pre></div>


<details class="note" open>
  <summary>Note</summary>
  <p>Areas with None or NaN values in the area_column are excluded
from the generated model.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/area_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_base_area_model_from_area_names_in_node_model_df</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate base area model DataFrame from unique area names in node data.</span>

<span class="sd">    Creates a minimal area model DataFrame containing only the unique area</span>
<span class="sd">    identifiers found in the node model data. This forms the foundation</span>
<span class="sd">    for building comprehensive area models.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Base area model with area identifiers as index.</span>
<span class="sd">            Contains no additional columns - serves as starting point</span>
<span class="sd">            for enhancement with node counts, geographic data, etc.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; generator = AreaModelGenerator(node_data, &#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; base_model = generator.generate_base_area_model_from_area_names_in_node_model_df()</span>
<span class="sd">        &gt;&gt;&gt; print(base_model)</span>
<span class="sd">            Empty DataFrame</span>
<span class="sd">            Columns: []</span>
<span class="sd">            Index: [&#39;DE&#39;, &#39;FR&#39;, &#39;BE&#39;]</span>

<span class="sd">    Note:</span>
<span class="sd">        Areas with None or NaN values in the area_column are excluded</span>
<span class="sd">        from the generated model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="n">area_model_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">unique_areas</span><span class="p">)</span>
    <span class="n">area_model_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_column</span>
    <span class="k">return</span> <span class="n">area_model_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.ensure_completeness_of_area_model_df" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">ensure_completeness_of_area_model_df</span>


<a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.ensure_completeness_of_area_model_df" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">ensure_completeness_of_area_model_df</span><span class="p">(</span><span class="n">area_model_df</span><span class="p">:</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Ensure area model contains all areas present in node data.</p>
<p>Validates and extends an existing area model DataFrame to include
any areas found in the node data that might be missing from the
provided area model. This is useful when working with predefined
area models that may not cover all areas in the dataset.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_model_df</code>
            </td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Existing area model DataFrame to validate and extend.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pd.DataFrame: Complete area model containing all areas from node data.
Existing data is preserved, new areas are added with NaN values
for existing columns.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # Predefined area model missing some areas
&gt;&gt;&gt; partial_model = pd.DataFrame({
&gt;&gt;&gt;     &#39;max_price&#39;: [5000, 3000]
&gt;&gt;&gt; }, index=[&#39;DE&#39;, &#39;FR&#39;])
&gt;&gt;&gt; 
&gt;&gt;&gt; # Ensure completeness (adds &#39;BE&#39; if present in node data)
&gt;&gt;&gt; complete_model = generator.ensure_completeness_of_area_model_df(partial_model)
&gt;&gt;&gt; print(complete_model)
              max_price
    country
    DE             5000
    FR             3000
    BE              NaN
</code></pre></div>


<details class="use-case" open>
  <summary>Use Case</summary>
  <p>Essential for maintaining data consistency when combining
predefined area models with dynamic node-based area discovery.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/area_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">ensure_completeness_of_area_model_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure area model contains all areas present in node data.</span>

<span class="sd">    Validates and extends an existing area model DataFrame to include</span>
<span class="sd">    any areas found in the node data that might be missing from the</span>
<span class="sd">    provided area model. This is useful when working with predefined</span>
<span class="sd">    area models that may not cover all areas in the dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_model_df: Existing area model DataFrame to validate and extend.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Complete area model containing all areas from node data.</span>
<span class="sd">            Existing data is preserved, new areas are added with NaN values</span>
<span class="sd">            for existing columns.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; # Predefined area model missing some areas</span>
<span class="sd">        &gt;&gt;&gt; partial_model = pd.DataFrame({</span>
<span class="sd">        &gt;&gt;&gt;     &#39;max_price&#39;: [5000, 3000]</span>
<span class="sd">        &gt;&gt;&gt; }, index=[&#39;DE&#39;, &#39;FR&#39;])</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Ensure completeness (adds &#39;BE&#39; if present in node data)</span>
<span class="sd">        &gt;&gt;&gt; complete_model = generator.ensure_completeness_of_area_model_df(partial_model)</span>
<span class="sd">        &gt;&gt;&gt; print(complete_model)</span>
<span class="sd">                      max_price</span>
<span class="sd">            country</span>
<span class="sd">            DE             5000</span>
<span class="sd">            FR             3000</span>
<span class="sd">            BE              NaN</span>

<span class="sd">    Use Case:</span>
<span class="sd">        Essential for maintaining data consistency when combining</span>
<span class="sd">        predefined area models with dynamic node-based area discovery.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">complete_set</span> <span class="o">=</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">complete_set</span><span class="p">:</span>
            <span class="n">complete_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">complete_set</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_area_model_df_by_adding_node_count_per_area" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">enhance_area_model_df_by_adding_node_count_per_area</span>


<a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_area_model_df_by_adding_node_count_per_area" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">enhance_area_model_df_by_adding_node_count_per_area</span><span class="p">(</span><span class="n">area_model_df</span><span class="p">:</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span><span class="p">,</span> <span class="n">node_count_column_name</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="s1">&#39;node_count&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Enhance area model by adding node count statistics per area.</p>
<p>Aggregates the number of nodes assigned to each area and adds this
information to the area model DataFrame. Node counts are essential
for understanding infrastructure density and capacity distribution.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_model_df</code>
            </td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Base area model DataFrame to enhance.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>node_count_column_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name for the new node count column.
Defaults to 'node_count'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;node_count&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pd.DataFrame: Enhanced area model with node count column added.
Existing data is preserved, node counts are added for all areas.
Areas not present in node data will have NaN node counts.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; base_model = generator.generate_base_area_model_from_area_names_in_node_model_df()
&gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_node_count_per_area(base_model)
&gt;&gt;&gt; print(enhanced_model)
              node_count
    country
    DE               2
    FR               2
    BE               1

&gt;&gt;&gt; # Custom column name
&gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_node_count_per_area(
&gt;&gt;&gt;     base_model, &#39;infrastructure_count&#39;
&gt;&gt;&gt; )
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/area_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">enhance_area_model_df_by_adding_node_count_per_area</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">area_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">node_count_column_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;node_count&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhance area model by adding node count statistics per area.</span>

<span class="sd">    Aggregates the number of nodes assigned to each area and adds this</span>
<span class="sd">    information to the area model DataFrame. Node counts are essential</span>
<span class="sd">    for understanding infrastructure density and capacity distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_model_df: Base area model DataFrame to enhance.</span>
<span class="sd">        node_count_column_name: Name for the new node count column.</span>
<span class="sd">            Defaults to &#39;node_count&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Enhanced area model with node count column added.</span>
<span class="sd">            Existing data is preserved, node counts are added for all areas.</span>
<span class="sd">            Areas not present in node data will have NaN node counts.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; base_model = generator.generate_base_area_model_from_area_names_in_node_model_df()</span>
<span class="sd">        &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_node_count_per_area(base_model)</span>
<span class="sd">        &gt;&gt;&gt; print(enhanced_model)</span>
<span class="sd">                      node_count</span>
<span class="sd">            country</span>
<span class="sd">            DE               2</span>
<span class="sd">            FR               2</span>
<span class="sd">            BE               1</span>

<span class="sd">        &gt;&gt;&gt; # Custom column name</span>
<span class="sd">        &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_node_count_per_area(</span>
<span class="sd">        &gt;&gt;&gt;     base_model, &#39;infrastructure_count&#39;</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">node_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">node_counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">node</span><span class="p">,</span> <span class="n">node_count_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
    <span class="k">return</span> <span class="n">enhanced_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_area_model_df_by_adding_representative_geo_point" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">enhance_area_model_df_by_adding_representative_geo_point</span>


<a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_area_model_df_by_adding_representative_geo_point" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">enhance_area_model_df_by_adding_representative_geo_point</span><span class="p">(</span><span class="n">area_model_df</span><span class="p">:</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span> <span class="o">|</span> <span class="n"><span title="geopandas.GeoDataFrame">GeoDataFrame</span></span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="s1">&#39;projection_point&#39;</span><span class="p">,</span> <span class="n">round_point_decimals</span><span class="p">:</span> <span class="n"><span title="int">int</span></span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Enhance area model by adding representative geographic points for
labeling and KPI printing in map visualizations.</p>
<p>Calculates representative geographic points for each area based on
either area geometries (if available) or node locations within each area.
These points are useful for visualization, labeling, and spatial analysis.</p>
<p>The method supports two calculation modes:
1. Geometry-based: Uses area polygon centroids or representative points
2. Node-based: Calculates centroid from node locations within each area</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_model_df</code>
            </td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span> | <span title="geopandas.GeoDataFrame">GeoDataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Area model DataFrame to enhance. Can be regular DataFrame
or GeoDataFrame with 'geometry' column.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target_column_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name for the new representative point column.
Defaults to 'projection_point'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;projection_point&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>round_point_decimals</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of decimal places for coordinate rounding.
Set to None to disable rounding. Defaults to 4.</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pd.DataFrame: Enhanced area model with representative points added.
Points are added as Shapely Point objects suitable for mapping
and spatial analysis.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="TypeError">TypeError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If geo_location_column contains non-Point objects.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # Node-based representative points
&gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_representative_geo_point(base_model)
&gt;&gt;&gt; print(enhanced_model)
              projection_point
    country
    DE        POINT (10.5 52.5)
    FR        POINT (2.5 48.5)
    BE        POINT (4 50)

&gt;&gt;&gt; # With custom column name and precision
&gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_representative_geo_point(
&gt;&gt;&gt;     base_model, &#39;center_point&#39;, round_point_decimals=2
&gt;&gt;&gt; )

&gt;&gt;&gt; # Access coordinates for mapping
&gt;&gt;&gt; center = enhanced_model.loc[&#39;DE&#39;, &#39;projection_point&#39;]
&gt;&gt;&gt; print(f&quot;DE center: {center.x:.2f}, {center.y:.2f}&quot;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/area_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">enhance_area_model_df_by_adding_representative_geo_point</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">area_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">target_column_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;projection_point&#39;</span><span class="p">,</span>
        <span class="n">round_point_decimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhance area model by adding representative geographic points for</span>
<span class="sd">    labeling and KPI printing in map visualizations.</span>

<span class="sd">    Calculates representative geographic points for each area based on</span>
<span class="sd">    either area geometries (if available) or node locations within each area.</span>
<span class="sd">    These points are useful for visualization, labeling, and spatial analysis.</span>

<span class="sd">    The method supports two calculation modes:</span>
<span class="sd">    1. Geometry-based: Uses area polygon centroids or representative points</span>
<span class="sd">    2. Node-based: Calculates centroid from node locations within each area</span>

<span class="sd">    Args:</span>
<span class="sd">        area_model_df: Area model DataFrame to enhance. Can be regular DataFrame</span>
<span class="sd">            or GeoDataFrame with &#39;geometry&#39; column.</span>
<span class="sd">        target_column_name: Name for the new representative point column.</span>
<span class="sd">            Defaults to &#39;projection_point&#39;.</span>
<span class="sd">        round_point_decimals: Number of decimal places for coordinate rounding.</span>
<span class="sd">            Set to None to disable rounding. Defaults to 4.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Enhanced area model with representative points added.</span>
<span class="sd">            Points are added as Shapely Point objects suitable for mapping</span>
<span class="sd">            and spatial analysis.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If geo_location_column contains non-Point objects.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; # Node-based representative points</span>
<span class="sd">        &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_representative_geo_point(base_model)</span>
<span class="sd">        &gt;&gt;&gt; print(enhanced_model)</span>
<span class="sd">                      projection_point</span>
<span class="sd">            country</span>
<span class="sd">            DE        POINT (10.5 52.5)</span>
<span class="sd">            FR        POINT (2.5 48.5)</span>
<span class="sd">            BE        POINT (4 50)</span>

<span class="sd">        &gt;&gt;&gt; # With custom column name and precision</span>
<span class="sd">        &gt;&gt;&gt; enhanced_model = generator.enhance_area_model_df_by_adding_representative_geo_point(</span>
<span class="sd">        &gt;&gt;&gt;     base_model, &#39;center_point&#39;, round_point_decimals=2</span>
<span class="sd">        &gt;&gt;&gt; )</span>

<span class="sd">        &gt;&gt;&gt; # Access coordinates for mapping</span>
<span class="sd">        &gt;&gt;&gt; center = enhanced_model.loc[&#39;DE&#39;, &#39;projection_point&#39;]</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;DE center: {center.x:.2f}, {center.y:.2f}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">round_point</span><span class="p">(</span><span class="n">point</span><span class="p">:</span> <span class="n">Point</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Point</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">round_point_decimals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">point</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">point</span><span class="p">)(</span><span class="nb">round</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">round_point_decimals</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">round_point_decimals</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">target_column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="p">:</span>
        <span class="n">enhanced_df</span><span class="p">[</span><span class="n">target_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">]):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">geo</span> <span class="o">=</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">notna</span><span class="p">(</span><span class="n">geo</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geo</span><span class="p">,</span> <span class="p">(</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">)):</span>
                <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">round_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_representative_area_point</span><span class="p">(</span><span class="n">geo</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_location_column</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">area</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_location_column</span><span class="p">]</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">locations</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Point</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">locations</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Geographic location column &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_location_column</span><span class="si">}</span><span class="s1">&quot; must contain only &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Point objects. Found: </span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">locations</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="p">)]</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                <span class="n">representative_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_representative_point_from_cloud_of_2d_points</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
                <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">round_point</span><span class="p">(</span><span class="n">representative_point</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">enhanced_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.generate_area_model" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">generate_area_model</span>


<a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.generate_area_model" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">generate_area_model</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate complete area model with node counts and representative points.</p>
<p>Creates a comprehensive area model DataFrame by combining base area
discovery, node count aggregation, and representative geographic point
calculation. This is the main method for generating complete area models.</p>


<details class="the-generated-model-includes" open>
  <summary>The generated model includes</summary>
  <ul>
<li>All unique areas from node data</li>
<li>Node count per area for capacity/infrastructure analysis</li>
<li>Representative geographic points for visualization</li>
</ul>
</details>

    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pd.DataFrame: Complete area model with node counts and geographic data.
Index contains area identifiers, columns include 'node_count'
and 'projection_point' (if geographic data available).</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; generator = AreaModelGenerator(node_data, &#39;country&#39;)
&gt;&gt;&gt; area_model = generator.generate_area_model()
&gt;&gt;&gt; print(area_model)
              node_count projection_point
    country
    DE               2    POINT (10.5 52.5)
    FR               2    POINT (2.5 48.5)
    BE               1    POINT (4 50)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/area_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_area_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate complete area model with node counts and representative points.</span>

<span class="sd">    Creates a comprehensive area model DataFrame by combining base area</span>
<span class="sd">    discovery, node count aggregation, and representative geographic point</span>
<span class="sd">    calculation. This is the main method for generating complete area models.</span>

<span class="sd">    The generated model includes:</span>
<span class="sd">        - All unique areas from node data</span>
<span class="sd">        - Node count per area for capacity/infrastructure analysis</span>
<span class="sd">        - Representative geographic points for visualization</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Complete area model with node counts and geographic data.</span>
<span class="sd">            Index contains area identifiers, columns include &#39;node_count&#39;</span>
<span class="sd">            and &#39;projection_point&#39; (if geographic data available).</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; generator = AreaModelGenerator(node_data, &#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; area_model = generator.generate_area_model()</span>
<span class="sd">        &gt;&gt;&gt; print(area_model)</span>
<span class="sd">                      node_count projection_point</span>
<span class="sd">            country</span>
<span class="sd">            DE               2    POINT (10.5 52.5)</span>
<span class="sd">            FR               2    POINT (2.5 48.5)</span>
<span class="sd">            BE               1    POINT (4 50)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">area_model_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_base_area_model_from_area_names_in_node_model_df</span><span class="p">()</span>
    <span class="n">area_model_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enhance_area_model_df_by_adding_node_count_per_area</span><span class="p">(</span><span class="n">area_model_df</span><span class="p">)</span>
    <span class="n">area_model_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enhance_area_model_df_by_adding_representative_geo_point</span><span class="p">(</span><span class="n">area_model_df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area_model_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_with_geometry" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">enhance_with_geometry</span>


<a href="#mescal.energy_data_handling.area_accounting.area_model_generator.AreaModelGenerator.enhance_with_geometry" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">enhance_with_geometry</span><span class="p">(</span><span class="n">area_model_df</span><span class="p">:</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span><span class="p">,</span> <span class="n">area_gdf</span><span class="p">:</span> <span class="n"><span title="geopandas.GeoDataFrame">GeoDataFrame</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="geopandas.GeoDataFrame">GeoDataFrame</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Enhance area model with geometric polygon data for spatial analysis.</p>
<p>Integrates area polygon geometries from a GeoDataFrame into the area model,
enabling advanced spatial analysis, visualization, and border calculations.
The method matches areas by index and creates a proper GeoDataFrame output.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_model_df</code>
            </td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Area model DataFrame to enhance with geometry.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_gdf</code>
            </td>
            <td>
                  <code><span title="geopandas.GeoDataFrame">GeoDataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>GeoDataFrame containing area polygon geometries.
Must have 'geometry' column with Polygon or MultiPolygon objects.
Areas are matched by index values.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="geopandas.GeoDataFrame">GeoDataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>gpd.GeoDataFrame: Enhanced area model as GeoDataFrame with geometry column.
All original data is preserved, geometry column is added for areas
that exist in both DataFrames. Missing geometries are set to None.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; import geopandas as gpd
&gt;&gt;&gt; from shapely.geometry import Polygon
&gt;&gt;&gt; 
&gt;&gt;&gt; # Create area geometries
&gt;&gt;&gt; area_polygons = gpd.GeoDataFrame({
&gt;&gt;&gt;     &#39;area_name&#39;: [&#39;Germany&#39;, &#39;France&#39;, &#39;Belgium&#39;],
&gt;&gt;&gt;     &#39;geometry&#39;: [
&gt;&gt;&gt;         Polygon([(9, 51), (12, 51), (12, 54), (9, 54)]),
&gt;&gt;&gt;         Polygon([(1, 47), (4, 47), (4, 50), (1, 50)]),
&gt;&gt;&gt;         Polygon([(3, 49), (5, 49), (5, 51), (3, 51)])
&gt;&gt;&gt;     ]
&gt;&gt;&gt; }, index=[&#39;DE&#39;, &#39;FR&#39;, &#39;BE&#39;])
&gt;&gt;&gt; 
&gt;&gt;&gt; # Enhance area model with geometry
&gt;&gt;&gt; geo_model = generator.enhance_with_geometry(area_model, area_polygons)
&gt;&gt;&gt; print(f&quot;Model has geometry: {isinstance(geo_model, gpd.GeoDataFrame)}&quot;)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Use for spatial operations
&gt;&gt;&gt; total_area = geo_model[&#39;geometry&#39;].area.sum()
&gt;&gt;&gt; print(f&quot;Total area: {total_area:.0f} square units&quot;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/area_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">enhance_with_geometry</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">area_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">area_gdf</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhance area model with geometric polygon data for spatial analysis.</span>

<span class="sd">    Integrates area polygon geometries from a GeoDataFrame into the area model,</span>
<span class="sd">    enabling advanced spatial analysis, visualization, and border calculations.</span>
<span class="sd">    The method matches areas by index and creates a proper GeoDataFrame output.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_model_df: Area model DataFrame to enhance with geometry.</span>
<span class="sd">        area_gdf: GeoDataFrame containing area polygon geometries.</span>
<span class="sd">            Must have &#39;geometry&#39; column with Polygon or MultiPolygon objects.</span>
<span class="sd">            Areas are matched by index values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        gpd.GeoDataFrame: Enhanced area model as GeoDataFrame with geometry column.</span>
<span class="sd">            All original data is preserved, geometry column is added for areas</span>
<span class="sd">            that exist in both DataFrames. Missing geometries are set to None.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Create area geometries</span>
<span class="sd">        &gt;&gt;&gt; area_polygons = gpd.GeoDataFrame({</span>
<span class="sd">        &gt;&gt;&gt;     &#39;area_name&#39;: [&#39;Germany&#39;, &#39;France&#39;, &#39;Belgium&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;geometry&#39;: [</span>
<span class="sd">        &gt;&gt;&gt;         Polygon([(9, 51), (12, 51), (12, 54), (9, 54)]),</span>
<span class="sd">        &gt;&gt;&gt;         Polygon([(1, 47), (4, 47), (4, 50), (1, 50)]),</span>
<span class="sd">        &gt;&gt;&gt;         Polygon([(3, 49), (5, 49), (5, 51), (3, 51)])</span>
<span class="sd">        &gt;&gt;&gt;     ]</span>
<span class="sd">        &gt;&gt;&gt; }, index=[&#39;DE&#39;, &#39;FR&#39;, &#39;BE&#39;])</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Enhance area model with geometry</span>
<span class="sd">        &gt;&gt;&gt; geo_model = generator.enhance_with_geometry(area_model, area_polygons)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Model has geometry: {isinstance(geo_model, gpd.GeoDataFrame)}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Use for spatial operations</span>
<span class="sd">        &gt;&gt;&gt; total_area = geo_model[&#39;geometry&#39;].area.sum()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Total area: {total_area:.0f} square units&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">enhanced_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">enhanced_df</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">area_model_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">area_gdf</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enhanced_df</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
        <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">enhanced_df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">enhanced_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>

<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>Border model generation for energy system area connectivity analysis.</p>
<p>This module provides functionality for identifying and modeling borders between
energy system areas based on line topologies. It supports the
creation of comprehensive border_model_dfs that capture directional relationships,
naming conventions, and geometric properties essential for energy systems analysis.</p>


<details class="key-capabilities" open>
  <summary>Key Capabilities</summary>
  <ul>
<li>Automatic border identification from line topology</li>
<li>Standardized border naming conventions with directional awareness</li>
<li>Integration with geometric border calculators</li>
<li>Network graph generation for area connectivity analysis</li>
<li>Support for both physical and logical borders (geographically touching borders vs geographically separated borders)</li>
</ul>
</details>

<details class="typical-energy-use-cases" open>
  <summary>Typical Energy Use Cases</summary>
  <ul>
<li>Modeling interconnections between countries, control areas, or market zones</li>
<li>Cross-border capacity and flow analysis</li>
<li>Network visualization and analysis</li>
</ul>
</details>

<details class="mescal-integration" open>
  <summary>MESCAL Integration</summary>
  <p>This module integrates with MESCAL's area accounting system to provide
border_model_df building capabilities that support spatial energy system analysis
and cross-border flow calculations.</p>
</details>









  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">AreaBorderNamingConventions</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">


        <p>Standardized naming conventions for energy system area borders.</p>
<p>This class provides consistent naming patterns for borders between energy
system areas (countries, bidding zones, market regions). It ensures
standardized naming across different analysis workflows and supports
bidirectional relationship management.</p>


<details class="the-naming-system-supports" open>
  <summary>The naming system supports</summary>
  <ul>
<li>Configurable separators and prefixes/suffixes</li>
<li>Bidirectional border identification (A-B and B-A)</li>
<li>Alphabetically sorted canonical border names</li>
<li>Consistent column naming for source and target areas</li>
</ul>
</details>

<details class="key-features" open>
  <summary>Key Features</summary>
  <ul>
<li>Configurable naming patterns for different use cases</li>
<li>Automatic opposite border name generation</li>
<li>Alphabetical sorting for canonical border representation</li>
<li>Consistent identifier generation for database/DataFrame columns</li>
</ul>
</details>

<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.JOIN_AREA_NAMES_BY">JOIN_AREA_NAMES_BY</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Separator for area names in border identifiers</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.SOURCE_AREA_IDENTIFIER_SUFFIX">SOURCE_AREA_IDENTIFIER_SUFFIX</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Suffix for source area column names</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.TARGET_AREA_IDENTIFIER_SUFFIX">TARGET_AREA_IDENTIFIER_SUFFIX</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Suffix for target area column names</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.OPPOSITE_BORDER_IDENTIFIER">OPPOSITE_BORDER_IDENTIFIER</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name for opposite border references</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.SORTED_BORDER_IDENTIFIER">SORTED_BORDER_IDENTIFIER</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name for alphabetically sorted borders</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.NAME_IS_ALPHABETICALLY_SORTED_IDENTIFIER">NAME_IS_ALPHABETICALLY_SORTED_IDENTIFIER</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Boolean indicator column</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)
&gt;&gt;&gt; border_name = conventions.get_area_border_name(&#39;DE&#39;, &#39;FR&#39;)
&gt;&gt;&gt; print(border_name)  # &#39;DE - FR&#39;
&gt;&gt;&gt; opposite = conventions.get_opposite_area_border_name(border_name)
&gt;&gt;&gt; print(opposite)  # &#39;FR - DE&#39;
</code></pre></div>








              <details class="quote">
                <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AreaBorderNamingConventions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Standardized naming conventions for energy system area borders.</span>

<span class="sd">    This class provides consistent naming patterns for borders between energy</span>
<span class="sd">    system areas (countries, bidding zones, market regions). It ensures</span>
<span class="sd">    standardized naming across different analysis workflows and supports</span>
<span class="sd">    bidirectional relationship management.</span>

<span class="sd">    The naming system supports:</span>
<span class="sd">        - Configurable separators and prefixes/suffixes</span>
<span class="sd">        - Bidirectional border identification (A-B and B-A)</span>
<span class="sd">        - Alphabetically sorted canonical border names</span>
<span class="sd">        - Consistent column naming for source and target areas</span>

<span class="sd">    Key Features:</span>
<span class="sd">        - Configurable naming patterns for different use cases</span>
<span class="sd">        - Automatic opposite border name generation</span>
<span class="sd">        - Alphabetical sorting for canonical border representation</span>
<span class="sd">        - Consistent identifier generation for database/DataFrame columns</span>

<span class="sd">    Attributes:</span>
<span class="sd">        JOIN_AREA_NAMES_BY (str): Separator for area names in border identifiers</span>
<span class="sd">        SOURCE_AREA_IDENTIFIER_SUFFIX (str): Suffix for source area column names</span>
<span class="sd">        TARGET_AREA_IDENTIFIER_SUFFIX (str): Suffix for target area column names</span>
<span class="sd">        OPPOSITE_BORDER_IDENTIFIER (str): Column name for opposite border references</span>
<span class="sd">        SORTED_BORDER_IDENTIFIER (str): Column name for alphabetically sorted borders</span>
<span class="sd">        NAME_IS_ALPHABETICALLY_SORTED_IDENTIFIER (str): Boolean indicator column</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; border_name = conventions.get_area_border_name(&#39;DE&#39;, &#39;FR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(border_name)  # &#39;DE - FR&#39;</span>
<span class="sd">        &gt;&gt;&gt; opposite = conventions.get_opposite_area_border_name(border_name)</span>
<span class="sd">        &gt;&gt;&gt; print(opposite)  # &#39;FR - DE&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">JOIN_AREA_NAMES_BY</span> <span class="o">=</span> <span class="s1">&#39; - &#39;</span>
    <span class="n">SOURCE_AREA_IDENTIFIER_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">TARGET_AREA_IDENTIFIER_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">SOURCE_AREA_IDENTIFIER_SUFFIX</span> <span class="o">=</span> <span class="s1">&#39;_from&#39;</span>
    <span class="n">TARGET_AREA_IDENTIFIER_SUFFIX</span> <span class="o">=</span> <span class="s1">&#39;_to&#39;</span>
    <span class="n">OPPOSITE_BORDER_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;opposite_border&#39;</span>
    <span class="n">SORTED_BORDER_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;sorted_border&#39;</span>
    <span class="n">NAME_IS_ALPHABETICALLY_SORTED_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;name_is_alphabetically_sorted&#39;</span>
    <span class="n">PROJECTION_POINT_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;projection_point&#39;</span>
    <span class="n">AZIMUTH_ANGLE_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;azimuth_angle&#39;</span>
    <span class="n">BORDER_IS_PHYSICAL_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;is_physical&#39;</span>
    <span class="n">BORDER_LINE_STRING_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;geo_line_string&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">area_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">border_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">source_area_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">target_area_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize border naming conventions.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_column: Name of the area column (e.g., &#39;country&#39;, &#39;bidding_zone&#39;)</span>
<span class="sd">            border_identifier: Custom name for border identifier column.</span>
<span class="sd">                Defaults to &#39;{area_column}_border&#39;</span>
<span class="sd">            source_area_identifier: Custom name for source area column.</span>
<span class="sd">                Defaults to &#39;{area_column}_from&#39;</span>
<span class="sd">            target_area_identifier: Custom name for target area column.</span>
<span class="sd">                Defaults to &#39;{area_column}_to&#39;</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; # Standard naming</span>
<span class="sd">            &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(conventions.border_identifier)  # &#39;country_border&#39;</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Custom naming</span>
<span class="sd">            &gt;&gt;&gt; conventions = AreaBorderNamingConventions(</span>
<span class="sd">            ...     &#39;bidding_zone&#39;,</span>
<span class="sd">            ...     border_identifier=&#39;interconnection&#39;,</span>
<span class="sd">            ...     source_area_identifier=&#39;origin_zone&#39;</span>
<span class="sd">            ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_column</span> <span class="o">=</span> <span class="n">area_column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">border_identifier</span> <span class="o">=</span> <span class="n">border_identifier</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_border_identifier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_area_identifier</span> <span class="o">=</span> <span class="n">source_area_identifier</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_source_area_identifier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_area_identifier</span> <span class="o">=</span> <span class="n">target_area_identifier</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_target_area_identifier</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_default_border_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="si">}</span><span class="s1">_border&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_default_source_area_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_AREA_IDENTIFIER_PREFIX</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">SOURCE_AREA_IDENTIFIER_SUFFIX</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_default_target_area_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">TARGET_AREA_IDENTIFIER_PREFIX</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">TARGET_AREA_IDENTIFIER_SUFFIX</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_area_border_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate standardized border name from source and target areas.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_from: Source area identifier (e.g., &#39;DE&#39;, &#39;FR_North&#39;)</span>
<span class="sd">            area_to: Target area identifier (e.g., &#39;FR&#39;, &#39;DE_South&#39;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Formatted border name using the configured separator (e.g. &#39;DE - FR&#39;, &#39;FR_North - DE_South&#39;)</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">            &gt;&gt;&gt; border_name = conventions.get_area_border_name(&#39;DE&#39;, &#39;FR&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(border_name)  # &#39;DE - FR&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">area_from</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">JOIN_AREA_NAMES_BY</span><span class="si">}{</span><span class="n">area_to</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">decompose_area_border_name_to_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">border_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract source and target area names from border identifier.</span>

<span class="sd">        Args:</span>
<span class="sd">            border_name: Border name in standard format (e.g., &#39;DE - FR&#39;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[str, str]: Source and target area names</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If border_name doesn&#39;t contain the expected separator</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">            &gt;&gt;&gt; area_from, area_to = conventions.decompose_area_border_name_to_areas(&#39;DE - FR&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;From: {area_from}, To: {area_to}&quot;)  # From: DE, To: FR</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="o">=</span> <span class="n">border_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JOIN_AREA_NAMES_BY</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_opposite_area_border_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">border_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the opposite direction border name.</span>

<span class="sd">        Args:</span>
<span class="sd">            border_name: Original border name (e.g., &#39;DE - FR&#39;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Opposite direction border name (e.g., &#39;FR - DE&#39;)</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">            &gt;&gt;&gt; opposite = conventions.get_opposite_area_border_name(&#39;DE - FR&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(opposite)  # &#39;FR - DE&#39;</span>

<span class="sd">        Energy Domain Context:</span>
<span class="sd">            Energy flows and capacities are often directional, requiring</span>
<span class="sd">            tracking of both A→B and B→A relationships for comprehensive</span>
<span class="sd">            border analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_area_border_name_to_areas</span><span class="p">(</span><span class="n">border_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_border_name</span><span class="p">(</span><span class="n">area_to</span><span class="p">,</span> <span class="n">area_from</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_alphabetically_sorted_border</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">border_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate alphabetically sorted canonical border name.</span>

<span class="sd">        Creates a canonical representation where area names are sorted</span>
<span class="sd">        alphabetically, useful for identifying unique borders regardless</span>
<span class="sd">        of direction specification, or for matching borders of opposite direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            border_name: Border name in any direction (e.g., &#39;FR - DE&#39; or &#39;DE - FR&#39;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Alphabetically sorted border name (e.g., &#39;DE - FR&#39;)</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">            &gt;&gt;&gt; sorted_border = conventions.get_alphabetically_sorted_border(&#39;FR - DE&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(sorted_border)  # &#39;DE - FR&#39;</span>

<span class="sd">        Use Case:</span>
<span class="sd">            Canonical naming is essential for border deduplication and</span>
<span class="sd">            consistent reference in energy system databases and analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_area_border_name_to_areas</span><span class="p">(</span><span class="n">border_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_border_name</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">])))</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.__init__" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">__init__</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.__init__" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">__init__</span><span class="p">(</span><span class="n">area_column</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">border_identifier</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">source_area_identifier</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_area_identifier</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Initialize border naming conventions.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_column</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name of the area column (e.g., 'country', 'bidding_zone')</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>border_identifier</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Custom name for border identifier column.
Defaults to '{area_column}_border'</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>source_area_identifier</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Custom name for source area column.
Defaults to '{area_column}_from'</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target_area_identifier</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Custom name for target area column.
Defaults to '{area_column}_to'</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # Standard naming
&gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)
&gt;&gt;&gt; print(conventions.border_identifier)  # &#39;country_border&#39;
&gt;&gt;&gt; 
&gt;&gt;&gt; # Custom naming
&gt;&gt;&gt; conventions = AreaBorderNamingConventions(
...     &#39;bidding_zone&#39;,
...     border_identifier=&#39;interconnection&#39;,
...     source_area_identifier=&#39;origin_zone&#39;
... )
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">area_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">border_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source_area_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target_area_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize border naming conventions.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_column: Name of the area column (e.g., &#39;country&#39;, &#39;bidding_zone&#39;)</span>
<span class="sd">        border_identifier: Custom name for border identifier column.</span>
<span class="sd">            Defaults to &#39;{area_column}_border&#39;</span>
<span class="sd">        source_area_identifier: Custom name for source area column.</span>
<span class="sd">            Defaults to &#39;{area_column}_from&#39;</span>
<span class="sd">        target_area_identifier: Custom name for target area column.</span>
<span class="sd">            Defaults to &#39;{area_column}_to&#39;</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; # Standard naming</span>
<span class="sd">        &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(conventions.border_identifier)  # &#39;country_border&#39;</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Custom naming</span>
<span class="sd">        &gt;&gt;&gt; conventions = AreaBorderNamingConventions(</span>
<span class="sd">        ...     &#39;bidding_zone&#39;,</span>
<span class="sd">        ...     border_identifier=&#39;interconnection&#39;,</span>
<span class="sd">        ...     source_area_identifier=&#39;origin_zone&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">area_column</span> <span class="o">=</span> <span class="n">area_column</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">border_identifier</span> <span class="o">=</span> <span class="n">border_identifier</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_border_identifier</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">source_area_identifier</span> <span class="o">=</span> <span class="n">source_area_identifier</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_source_area_identifier</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">target_area_identifier</span> <span class="o">=</span> <span class="n">target_area_identifier</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_target_area_identifier</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_area_border_name" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_area_border_name</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_area_border_name" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_area_border_name</span><span class="p">(</span><span class="n">area_from</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="str">str</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate standardized border name from source and target areas.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_from</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Source area identifier (e.g., 'DE', 'FR_North')</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_to</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target area identifier (e.g., 'FR', 'DE_South')</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>str</code></td>            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Formatted border name using the configured separator (e.g. 'DE - FR', 'FR_North - DE_South')</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)
&gt;&gt;&gt; border_name = conventions.get_area_border_name(&#39;DE&#39;, &#39;FR&#39;)
&gt;&gt;&gt; print(border_name)  # &#39;DE - FR&#39;
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_area_border_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate standardized border name from source and target areas.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_from: Source area identifier (e.g., &#39;DE&#39;, &#39;FR_North&#39;)</span>
<span class="sd">        area_to: Target area identifier (e.g., &#39;FR&#39;, &#39;DE_South&#39;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: Formatted border name using the configured separator (e.g. &#39;DE - FR&#39;, &#39;FR_North - DE_South&#39;)</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; border_name = conventions.get_area_border_name(&#39;DE&#39;, &#39;FR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(border_name)  # &#39;DE - FR&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">area_from</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">JOIN_AREA_NAMES_BY</span><span class="si">}{</span><span class="n">area_to</span><span class="si">}</span><span class="s1">&#39;</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.decompose_area_border_name_to_areas" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">decompose_area_border_name_to_areas</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.decompose_area_border_name_to_areas" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">decompose_area_border_name_to_areas</span><span class="p">(</span><span class="n">border_name</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="typing.Tuple">Tuple</span></span><span class="p">[</span><span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n"><span title="str">str</span></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Extract source and target area names from border identifier.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>border_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Border name in standard format (e.g., 'DE - FR')</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Tuple">Tuple</span>[<span title="str">str</span>, <span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Tuple[str, str]: Source and target area names</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If border_name doesn't contain the expected separator</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)
&gt;&gt;&gt; area_from, area_to = conventions.decompose_area_border_name_to_areas(&#39;DE - FR&#39;)
&gt;&gt;&gt; print(f&quot;From: {area_from}, To: {area_to}&quot;)  # From: DE, To: FR
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">decompose_area_border_name_to_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">border_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract source and target area names from border identifier.</span>

<span class="sd">    Args:</span>
<span class="sd">        border_name: Border name in standard format (e.g., &#39;DE - FR&#39;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[str, str]: Source and target area names</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If border_name doesn&#39;t contain the expected separator</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; area_from, area_to = conventions.decompose_area_border_name_to_areas(&#39;DE - FR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;From: {area_from}, To: {area_to}&quot;)  # From: DE, To: FR</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="o">=</span> <span class="n">border_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JOIN_AREA_NAMES_BY</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_opposite_area_border_name" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_opposite_area_border_name</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_opposite_area_border_name" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_opposite_area_border_name</span><span class="p">(</span><span class="n">border_name</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="str">str</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate the opposite direction border name.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>border_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Original border name (e.g., 'DE - FR')</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>str</code></td>            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Opposite direction border name (e.g., 'FR - DE')</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)
&gt;&gt;&gt; opposite = conventions.get_opposite_area_border_name(&#39;DE - FR&#39;)
&gt;&gt;&gt; print(opposite)  # &#39;FR - DE&#39;
</code></pre></div>


<details class="energy-domain-context" open>
  <summary>Energy Domain Context</summary>
  <p>Energy flows and capacities are often directional, requiring
tracking of both A→B and B→A relationships for comprehensive
border analysis.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_opposite_area_border_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">border_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the opposite direction border name.</span>

<span class="sd">    Args:</span>
<span class="sd">        border_name: Original border name (e.g., &#39;DE - FR&#39;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: Opposite direction border name (e.g., &#39;FR - DE&#39;)</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; opposite = conventions.get_opposite_area_border_name(&#39;DE - FR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(opposite)  # &#39;FR - DE&#39;</span>

<span class="sd">    Energy Domain Context:</span>
<span class="sd">        Energy flows and capacities are often directional, requiring</span>
<span class="sd">        tracking of both A→B and B→A relationships for comprehensive</span>
<span class="sd">        border analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_area_border_name_to_areas</span><span class="p">(</span><span class="n">border_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_border_name</span><span class="p">(</span><span class="n">area_to</span><span class="p">,</span> <span class="n">area_from</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_alphabetically_sorted_border" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_alphabetically_sorted_border</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions.get_alphabetically_sorted_border" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_alphabetically_sorted_border</span><span class="p">(</span><span class="n">border_name</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="str">str</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate alphabetically sorted canonical border name.</p>
<p>Creates a canonical representation where area names are sorted
alphabetically, useful for identifying unique borders regardless
of direction specification, or for matching borders of opposite direction.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>border_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Border name in any direction (e.g., 'FR - DE' or 'DE - FR')</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>str</code></td>            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Alphabetically sorted border name (e.g., 'DE - FR')</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)
&gt;&gt;&gt; sorted_border = conventions.get_alphabetically_sorted_border(&#39;FR - DE&#39;)
&gt;&gt;&gt; print(sorted_border)  # &#39;DE - FR&#39;
</code></pre></div>


<details class="use-case" open>
  <summary>Use Case</summary>
  <p>Canonical naming is essential for border deduplication and
consistent reference in energy system databases and analysis.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_alphabetically_sorted_border</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">border_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate alphabetically sorted canonical border name.</span>

<span class="sd">    Creates a canonical representation where area names are sorted</span>
<span class="sd">    alphabetically, useful for identifying unique borders regardless</span>
<span class="sd">    of direction specification, or for matching borders of opposite direction.</span>

<span class="sd">    Args:</span>
<span class="sd">        border_name: Border name in any direction (e.g., &#39;FR - DE&#39; or &#39;DE - FR&#39;)</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: Alphabetically sorted border name (e.g., &#39;DE - FR&#39;)</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; conventions = AreaBorderNamingConventions(&#39;country&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sorted_border = conventions.get_alphabetically_sorted_border(&#39;FR - DE&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(sorted_border)  # &#39;DE - FR&#39;</span>

<span class="sd">    Use Case:</span>
<span class="sd">        Canonical naming is essential for border deduplication and</span>
<span class="sd">        consistent reference in energy system databases and analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_area_border_name_to_areas</span><span class="p">(</span><span class="n">border_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_border_name</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">])))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">AreaBorderModelGenerator</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="            AreaBorderNamingConventions (mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions)" href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderNamingConventions">AreaBorderNamingConventions</a></code></p>


        <p>Generates comprehensive border models from energy system topology.</p>
<p>This class analyzes line connectivity and node-to-area mappings
to automatically identify borders between energy system areas. It creates
a comprehensive border_model_df with standardized naming, directional relationships,
and integration points for geometric analysis.</p>
<p>The generator processes line topology data to identify cross-area connections.
It supports bidirectional relationship tracking and provides network graph
representations for connectivity analysis.</p>


<details class="key-features" open>
  <summary>Key Features</summary>
  <ul>
<li>Automatic border discovery from line topology</li>
<li>Bidirectional border relationship management</li>
<li>Standardized naming conventions with configurable patterns</li>
<li>Network graph generation for connectivity analysis</li>
<li>Integration with geometric border calculators</li>
<li>Support for different area granularities (countries, bidding zones, etc.)</li>
</ul>
</details>

<details class="mescal-integration" open>
  <summary>MESCAL Integration</summary>
  <p>Designed to work with MESCAL's area accounting system, providing
border modeling capabilities that integrate with flow calculators,
capacity analyzers, and visualization tools.</p>
</details>

<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.line_model_df">line_model_df</span></code></td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Transmission line data with topology information</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.node_model_df">node_model_df</span></code></td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Node data with area assignments</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.node_from_col">node_from_col</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name for line source nodes</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.node_to_col">node_to_col</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name for line target nodes</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.node_to_area_map">node_to_area_map</span></code></td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Mapping from nodes to their assigned areas</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # Create border model from transmission data
&gt;&gt;&gt; generator = AreaBorderModelGenerator(
...     node_df, line_df, &#39;country&#39;, &#39;node_from&#39;, &#39;node_to&#39;
... )
&gt;&gt;&gt; border_model = generator.generate_area_border_model()
&gt;&gt;&gt; print(f&quot;Found {len(border_model)} directional borders&quot;)
</code></pre></div>








              <details class="quote">
                <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AreaBorderModelGenerator</span><span class="p">(</span><span class="n">AreaBorderNamingConventions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates comprehensive border models from energy system topology.</span>

<span class="sd">    This class analyzes line connectivity and node-to-area mappings</span>
<span class="sd">    to automatically identify borders between energy system areas. It creates</span>
<span class="sd">    a comprehensive border_model_df with standardized naming, directional relationships,</span>
<span class="sd">    and integration points for geometric analysis.</span>

<span class="sd">    The generator processes line topology data to identify cross-area connections.</span>
<span class="sd">    It supports bidirectional relationship tracking and provides network graph</span>
<span class="sd">    representations for connectivity analysis.</span>

<span class="sd">    Key Features:</span>
<span class="sd">        - Automatic border discovery from line topology</span>
<span class="sd">        - Bidirectional border relationship management</span>
<span class="sd">        - Standardized naming conventions with configurable patterns</span>
<span class="sd">        - Network graph generation for connectivity analysis</span>
<span class="sd">        - Integration with geometric border calculators</span>
<span class="sd">        - Support for different area granularities (countries, bidding zones, etc.)</span>

<span class="sd">    MESCAL Integration:</span>
<span class="sd">        Designed to work with MESCAL&#39;s area accounting system, providing</span>
<span class="sd">        border modeling capabilities that integrate with flow calculators,</span>
<span class="sd">        capacity analyzers, and visualization tools.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        line_model_df (pd.DataFrame): Transmission line data with topology information</span>
<span class="sd">        node_model_df (pd.DataFrame): Node data with area assignments</span>
<span class="sd">        node_from_col (str): Column name for line source nodes</span>
<span class="sd">        node_to_col (str): Column name for line target nodes</span>
<span class="sd">        node_to_area_map (dict): Mapping from nodes to their assigned areas</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; # Create border model from transmission data</span>
<span class="sd">        &gt;&gt;&gt; generator = AreaBorderModelGenerator(</span>
<span class="sd">        ...     node_df, line_df, &#39;country&#39;, &#39;node_from&#39;, &#39;node_to&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; border_model = generator.generate_area_border_model()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Found {len(border_model)} directional borders&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">node_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">line_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">area_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">node_from_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">node_to_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">border_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source_area_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target_area_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the area border model generator.</span>

<span class="sd">        Args:</span>
<span class="sd">            node_model_df: DataFrame containing node-level data with area assignments.</span>
<span class="sd">                Must contain area_column with area identifiers for each node.</span>
<span class="sd">            line_model_df: DataFrame containing transmission line topology data.</span>
<span class="sd">                Must contain node_from_col and node_to_col with node identifiers.</span>
<span class="sd">            area_column: Column name in node_model_df containing area assignments</span>
<span class="sd">                (e.g., &#39;country&#39;, &#39;bidding_zone&#39;, &#39;market_region&#39;)</span>
<span class="sd">            node_from_col: Column name in line_model_df for source node identifiers</span>
<span class="sd">            node_to_col: Column name in line_model_df for target node identifiers</span>
<span class="sd">            border_identifier: Custom border column name (optional)</span>
<span class="sd">            source_area_identifier: Custom source area column name (optional)</span>
<span class="sd">            target_area_identifier: Custom target area column name (optional)</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If required columns are not found in input DataFrames</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; generator = AreaBorderModelGenerator(</span>
<span class="sd">            ...     nodes_df=node_data,</span>
<span class="sd">            ...     lines_df=transmission_data,</span>
<span class="sd">            ...     area_column=&#39;bidding_zone&#39;,</span>
<span class="sd">            ...     node_from_col=&#39;bus_from&#39;,</span>
<span class="sd">            ...     node_to_col=&#39;bus_to&#39;</span>
<span class="sd">            ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">area_column</span><span class="p">,</span> <span class="n">border_identifier</span><span class="p">,</span> <span class="n">source_area_identifier</span><span class="p">,</span> <span class="n">target_area_identifier</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_model_df</span> <span class="o">=</span> <span class="n">line_model_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span> <span class="o">=</span> <span class="n">node_model_df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_from_col</span> <span class="o">=</span> <span class="n">node_from_col</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_col</span> <span class="o">=</span> <span class="n">node_to_col</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_inputs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_to_area_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_node_to_area_map</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Area column &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="si">}</span><span class="s2">&#39; not found in node_model_df. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available columns: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_from_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Source node column &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node_from_col</span><span class="si">}</span><span class="s2">&#39; not found in line_model_df. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available columns: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Target node column &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node_to_col</span><span class="si">}</span><span class="s2">&#39; not found in line_model_df. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available columns: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">line_model_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_node_to_area_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create mapping from node identifiers to their assigned areas.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Mapping from node IDs to area assignments</span>

<span class="sd">        Note:</span>
<span class="sd">            Nodes with None or NaN area assignments are included in the mapping</span>
<span class="sd">            but will be filtered out during border identification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">area_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_area_border_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate comprehensive border model with all relationship data.</span>

<span class="sd">        Analyzes transmission line topology to identify borders between areas,</span>
<span class="sd">        creating a comprehensive DataFrame with directional relationships,</span>
<span class="sd">        naming conventions, and reference data for further analysis.</span>

<span class="sd">        The generated model includes:</span>
<span class="sd">            - Border identifiers in both directions (A→B and B→A)</span>
<span class="sd">            - Source and target area columns</span>
<span class="sd">            - Opposite border references for bidirectional analysis</span>
<span class="sd">            - Alphabetically sorted canonical border names</span>
<span class="sd">            - Boolean indicators for alphabetical sorting</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Comprehensive border model indexed by border identifiers.</span>
<span class="sd">                Returns empty DataFrame with proper column structure if no borders found.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; border_model = generator.generate_area_border_model()</span>
<span class="sd">            &gt;&gt;&gt; print(border_model.columns)</span>
<span class="sd">            [&#39;country_from&#39;, &#39;country_to&#39;, &#39;opposite_border&#39;, &#39;sorted_border&#39;, &#39;name_is_alphabetically_sorted&#39;]</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Access border relationships</span>
<span class="sd">            &gt;&gt;&gt; for border_id, row in border_model.iterrows():</span>
<span class="sd">            ...     print(f&quot;{border_id}: {row[&#39;country_from&#39;]} → {row[&#39;country_to&#39;]}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_borders</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">borders</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">border_identifier</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">source_area_identifier</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">target_area_identifier</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">OPPOSITE_BORDER_IDENTIFIER</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">SORTED_BORDER_IDENTIFIER</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">NAME_IS_ALPHABETICALLY_SORTED_IDENTIFIER</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

        <span class="n">border_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="ow">in</span> <span class="n">borders</span><span class="p">:</span>
            <span class="n">border_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_border_name</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>
            <span class="n">opposite_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_opposite_area_border_name</span><span class="p">(</span><span class="n">border_id</span><span class="p">)</span>

            <span class="n">sorted_border</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alphabetically_sorted_border</span><span class="p">(</span><span class="n">border_id</span><span class="p">)</span>

            <span class="n">border_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">border_identifier</span><span class="p">:</span> <span class="n">border_id</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source_area_identifier</span><span class="p">:</span> <span class="n">area_from</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_area_identifier</span><span class="p">:</span> <span class="n">area_to</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OPPOSITE_BORDER_IDENTIFIER</span><span class="p">:</span> <span class="n">opposite_id</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SORTED_BORDER_IDENTIFIER</span><span class="p">:</span> <span class="n">sorted_border</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">NAME_IS_ALPHABETICALLY_SORTED_IDENTIFIER</span><span class="p">:</span> <span class="n">sorted_border</span> <span class="o">==</span> <span class="n">border_id</span><span class="p">,</span>
            <span class="p">})</span>

        <span class="n">border_model_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">border_data</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">border_identifier</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">border_model_df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_identify_borders</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify borders from line topology.</span>

<span class="sd">        Analyzes line connectivity to find areas that are connected by</span>
<span class="sd">        lines, creating bidirectional border relationships.</span>

<span class="sd">        Returns:</span>
<span class="sd">            set: Set of (area_from, area_to) tuples representing directional borders.</span>
<span class="sd">                Includes both directions for each physical connection.</span>

<span class="sd">        Note:</span>
<span class="sd">            - Lines connecting nodes within the same area are ignored</span>
<span class="sd">            - Lines with nodes having None/NaN area assignments are ignored</span>
<span class="sd">            - Both directions (A→B and B→A) are included for each connection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_model_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">node_from</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_from_col</span><span class="p">]</span>
            <span class="n">node_to</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_to_col</span><span class="p">]</span>

            <span class="n">area_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_area_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_from</span><span class="p">)</span>
            <span class="n">area_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_area_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_to</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">area_from</span> <span class="ow">and</span> <span class="n">area_to</span> <span class="ow">and</span> <span class="n">area_from</span> <span class="o">!=</span> <span class="n">area_to</span><span class="p">:</span>
                <span class="n">borders</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">))</span>
                <span class="n">borders</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">area_to</span><span class="p">,</span> <span class="n">area_from</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">borders</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_lines_for_border</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all lines that cross a specific directional border.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_from: Source area identifier</span>
<span class="sd">            area_to: Target area identifier</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: List of line identifiers that connect the specified areas</span>
<span class="sd">                in the given direction</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; lines = generator._get_lines_for_border(&#39;DE&#39;, &#39;FR&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Lines from DE to FR: {lines}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">line_id</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_model_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">node_from</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_from_col</span><span class="p">]</span>
            <span class="n">node_to</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_to_col</span><span class="p">]</span>

            <span class="n">node_area_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_area_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_from</span><span class="p">)</span>
            <span class="n">node_area_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_to_area_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node_to</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">node_area_from</span> <span class="o">==</span> <span class="n">area_from</span> <span class="ow">and</span> <span class="n">node_area_to</span> <span class="o">==</span> <span class="n">area_to</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lines</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_area_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate NetworkX graph representation of area connectivity.</span>

<span class="sd">        Creates an undirected graph where nodes represent areas and edges</span>
<span class="sd">        represent borders. This is useful for network analysis, path finding,</span>
<span class="sd">        and connectivity studies in multi-area energy systems.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nx.Graph: Undirected graph with areas as nodes and borders as edges.</span>
<span class="sd">                Graph may contain multiple disconnected components if areas</span>
<span class="sd">                are not fully interconnected.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; graph = generator.get_area_graph()</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Areas: {list(graph.nodes())}&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Borders: {list(graph.edges())}&quot;)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Check connectivity</span>
<span class="sd">            &gt;&gt;&gt; connected = nx.is_connected(graph)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;All areas connected: {connected}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_borders</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="ow">in</span> <span class="n">borders</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">graph</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">enhance_with_geometry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">border_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">area_geometry_calculator</span><span class="p">:</span> <span class="n">AreaBorderGeometryCalculator</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enhance border model with geometric properties for visualization.</span>

<span class="sd">        Integrates with AreaBorderGeometryCalculator to add geometric information</span>
<span class="sd">        to borders, including representative points, directional angles, and</span>
<span class="sd">        line geometries. This enables advanced visualization of energy system borders.</span>

<span class="sd">        Args:</span>
<span class="sd">            border_model_df: Border model DataFrame to enhance</span>
<span class="sd">            area_geometry_calculator: Configured geometry calculator with area</span>
<span class="sd">                polygon data for geometric computations</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Enhanced border model with additional geometric columns:</span>
<span class="sd">                - projection_point: Point for label/arrow placement</span>
<span class="sd">                - azimuth_angle: Directional angle in degrees</span>
<span class="sd">                - is_physical: Boolean indicating if border is physical (touching areas)</span>
<span class="sd">                - geo_line_string: LineString geometry representing the border</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; # Setup geometry calculator with area polygons</span>
<span class="sd">            &gt;&gt;&gt; geo_calc = AreaBorderGeometryCalculator(area_polygons_gdf)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Enhance border model</span>
<span class="sd">            &gt;&gt;&gt; enhanced_borders = generator.enhance_with_geometry(border_model, geo_calc)</span>
<span class="sd">            &gt;&gt;&gt; print(enhanced_borders.columns)  # Includes geometric properties</span>

<span class="sd">        Note:</span>
<span class="sd">            Geometric enhancement may fail for some borders due to missing</span>
<span class="sd">            area geometries or calculation errors. Such failures are logged</span>
<span class="sd">            as warnings without stopping the overall process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">border_model_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">border_id</span><span class="p">,</span> <span class="n">border</span> <span class="ow">in</span> <span class="n">border_model_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">area_from</span> <span class="o">=</span> <span class="n">border</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source_area_identifier</span><span class="p">]</span>
            <span class="n">area_to</span> <span class="o">=</span> <span class="n">border</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_area_identifier</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">geometry_info</span> <span class="o">=</span> <span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">calculate_border_geometry</span><span class="p">(</span>
                    <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span>
                <span class="p">)</span>

                <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">border_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PROJECTION_POINT_IDENTIFIER</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry_info</span><span class="p">[</span><span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">PROJECTION_POINT_IDENTIFIER</span><span class="p">]</span>
                <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">border_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">AZIMUTH_ANGLE_IDENTIFIER</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry_info</span><span class="p">[</span><span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">AZIMUTH_ANGLE_IDENTIFIER</span><span class="p">]</span>
                <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">border_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BORDER_IS_PHYSICAL_IDENTIFIER</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry_info</span><span class="p">[</span><span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">BORDER_IS_PHYSICAL_IDENTIFIER</span><span class="p">]</span>
                <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">border_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BORDER_LINE_STRING_IDENTIFIER</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry_info</span><span class="p">[</span><span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">BORDER_LINE_STRING_IDENTIFIER</span><span class="p">]</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not calculate geometry for border </span><span class="si">{</span><span class="n">border_id</span><span class="si">}</span><span class="s2"> &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">area_from</span><span class="si">}</span><span class="s2"> → </span><span class="si">{</span><span class="n">area_to</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">enhanced_df</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.__init__" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">__init__</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.__init__" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">__init__</span><span class="p">(</span><span class="n">node_model_df</span><span class="p">:</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span><span class="p">,</span> <span class="n">line_model_df</span><span class="p">:</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span><span class="p">,</span> <span class="n">area_column</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">node_from_col</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">node_to_col</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">border_identifier</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">source_area_identifier</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">target_area_identifier</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Initialize the area border model generator.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>node_model_df</code>
            </td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>DataFrame containing node-level data with area assignments.
Must contain area_column with area identifiers for each node.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>line_model_df</code>
            </td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>DataFrame containing transmission line topology data.
Must contain node_from_col and node_to_col with node identifiers.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_column</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name in node_model_df containing area assignments
(e.g., 'country', 'bidding_zone', 'market_region')</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>node_from_col</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name in line_model_df for source node identifiers</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>node_to_col</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Column name in line_model_df for target node identifiers</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>border_identifier</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Custom border column name (optional)</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>source_area_identifier</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Custom source area column name (optional)</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>target_area_identifier</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Custom target area column name (optional)</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If required columns are not found in input DataFrames</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; generator = AreaBorderModelGenerator(
...     nodes_df=node_data,
...     lines_df=transmission_data,
...     area_column=&#39;bidding_zone&#39;,
...     node_from_col=&#39;bus_from&#39;,
...     node_to_col=&#39;bus_to&#39;
... )
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">node_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">line_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">area_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">node_from_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">node_to_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">border_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">source_area_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">target_area_identifier</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the area border model generator.</span>

<span class="sd">    Args:</span>
<span class="sd">        node_model_df: DataFrame containing node-level data with area assignments.</span>
<span class="sd">            Must contain area_column with area identifiers for each node.</span>
<span class="sd">        line_model_df: DataFrame containing transmission line topology data.</span>
<span class="sd">            Must contain node_from_col and node_to_col with node identifiers.</span>
<span class="sd">        area_column: Column name in node_model_df containing area assignments</span>
<span class="sd">            (e.g., &#39;country&#39;, &#39;bidding_zone&#39;, &#39;market_region&#39;)</span>
<span class="sd">        node_from_col: Column name in line_model_df for source node identifiers</span>
<span class="sd">        node_to_col: Column name in line_model_df for target node identifiers</span>
<span class="sd">        border_identifier: Custom border column name (optional)</span>
<span class="sd">        source_area_identifier: Custom source area column name (optional)</span>
<span class="sd">        target_area_identifier: Custom target area column name (optional)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If required columns are not found in input DataFrames</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; generator = AreaBorderModelGenerator(</span>
<span class="sd">        ...     nodes_df=node_data,</span>
<span class="sd">        ...     lines_df=transmission_data,</span>
<span class="sd">        ...     area_column=&#39;bidding_zone&#39;,</span>
<span class="sd">        ...     node_from_col=&#39;bus_from&#39;,</span>
<span class="sd">        ...     node_to_col=&#39;bus_to&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">area_column</span><span class="p">,</span> <span class="n">border_identifier</span><span class="p">,</span> <span class="n">source_area_identifier</span><span class="p">,</span> <span class="n">target_area_identifier</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">line_model_df</span> <span class="o">=</span> <span class="n">line_model_df</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_model_df</span> <span class="o">=</span> <span class="n">node_model_df</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_from_col</span> <span class="o">=</span> <span class="n">node_from_col</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_to_col</span> <span class="o">=</span> <span class="n">node_to_col</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_validate_inputs</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">node_to_area_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_node_to_area_map</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.generate_area_border_model" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">generate_area_border_model</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.generate_area_border_model" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">generate_area_border_model</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate comprehensive border model with all relationship data.</p>
<p>Analyzes transmission line topology to identify borders between areas,
creating a comprehensive DataFrame with directional relationships,
naming conventions, and reference data for further analysis.</p>


<details class="the-generated-model-includes" open>
  <summary>The generated model includes</summary>
  <ul>
<li>Border identifiers in both directions (A→B and B→A)</li>
<li>Source and target area columns</li>
<li>Opposite border references for bidirectional analysis</li>
<li>Alphabetically sorted canonical border names</li>
<li>Boolean indicators for alphabetical sorting</li>
</ul>
</details>

    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pd.DataFrame: Comprehensive border model indexed by border identifiers.
Returns empty DataFrame with proper column structure if no borders found.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; border_model = generator.generate_area_border_model()
&gt;&gt;&gt; print(border_model.columns)
[&#39;country_from&#39;, &#39;country_to&#39;, &#39;opposite_border&#39;, &#39;sorted_border&#39;, &#39;name_is_alphabetically_sorted&#39;]
&gt;&gt;&gt; 
&gt;&gt;&gt; # Access border relationships
&gt;&gt;&gt; for border_id, row in border_model.iterrows():
...     print(f&quot;{border_id}: {row[&#39;country_from&#39;]} → {row[&#39;country_to&#39;]}&quot;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_area_border_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate comprehensive border model with all relationship data.</span>

<span class="sd">    Analyzes transmission line topology to identify borders between areas,</span>
<span class="sd">    creating a comprehensive DataFrame with directional relationships,</span>
<span class="sd">    naming conventions, and reference data for further analysis.</span>

<span class="sd">    The generated model includes:</span>
<span class="sd">        - Border identifiers in both directions (A→B and B→A)</span>
<span class="sd">        - Source and target area columns</span>
<span class="sd">        - Opposite border references for bidirectional analysis</span>
<span class="sd">        - Alphabetically sorted canonical border names</span>
<span class="sd">        - Boolean indicators for alphabetical sorting</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Comprehensive border model indexed by border identifiers.</span>
<span class="sd">            Returns empty DataFrame with proper column structure if no borders found.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; border_model = generator.generate_area_border_model()</span>
<span class="sd">        &gt;&gt;&gt; print(border_model.columns)</span>
<span class="sd">        [&#39;country_from&#39;, &#39;country_to&#39;, &#39;opposite_border&#39;, &#39;sorted_border&#39;, &#39;name_is_alphabetically_sorted&#39;]</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Access border relationships</span>
<span class="sd">        &gt;&gt;&gt; for border_id, row in border_model.iterrows():</span>
<span class="sd">        ...     print(f&quot;{border_id}: {row[&#39;country_from&#39;]} → {row[&#39;country_to&#39;]}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">borders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_borders</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">borders</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">border_identifier</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source_area_identifier</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_area_identifier</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">OPPOSITE_BORDER_IDENTIFIER</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SORTED_BORDER_IDENTIFIER</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">NAME_IS_ALPHABETICALLY_SORTED_IDENTIFIER</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="n">border_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="ow">in</span> <span class="n">borders</span><span class="p">:</span>
        <span class="n">border_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_border_name</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>
        <span class="n">opposite_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_opposite_area_border_name</span><span class="p">(</span><span class="n">border_id</span><span class="p">)</span>

        <span class="n">sorted_border</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alphabetically_sorted_border</span><span class="p">(</span><span class="n">border_id</span><span class="p">)</span>

        <span class="n">border_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">border_identifier</span><span class="p">:</span> <span class="n">border_id</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_area_identifier</span><span class="p">:</span> <span class="n">area_from</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_area_identifier</span><span class="p">:</span> <span class="n">area_to</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">OPPOSITE_BORDER_IDENTIFIER</span><span class="p">:</span> <span class="n">opposite_id</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SORTED_BORDER_IDENTIFIER</span><span class="p">:</span> <span class="n">sorted_border</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NAME_IS_ALPHABETICALLY_SORTED_IDENTIFIER</span><span class="p">:</span> <span class="n">sorted_border</span> <span class="o">==</span> <span class="n">border_id</span><span class="p">,</span>
        <span class="p">})</span>

    <span class="n">border_model_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">border_data</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">border_identifier</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">border_model_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.get_area_graph" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_area_graph</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.get_area_graph" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_area_graph</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n"><span title="networkx.Graph">Graph</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate NetworkX graph representation of area connectivity.</p>
<p>Creates an undirected graph where nodes represent areas and edges
represent borders. This is useful for network analysis, path finding,
and connectivity studies in multi-area energy systems.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="networkx.Graph">Graph</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nx.Graph: Undirected graph with areas as nodes and borders as edges.
Graph may contain multiple disconnected components if areas
are not fully interconnected.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; graph = generator.get_area_graph()
&gt;&gt;&gt; print(f&quot;Areas: {list(graph.nodes())}&quot;)
&gt;&gt;&gt; print(f&quot;Borders: {list(graph.edges())}&quot;)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Check connectivity
&gt;&gt;&gt; connected = nx.is_connected(graph)
&gt;&gt;&gt; print(f&quot;All areas connected: {connected}&quot;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_area_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate NetworkX graph representation of area connectivity.</span>

<span class="sd">    Creates an undirected graph where nodes represent areas and edges</span>
<span class="sd">    represent borders. This is useful for network analysis, path finding,</span>
<span class="sd">    and connectivity studies in multi-area energy systems.</span>

<span class="sd">    Returns:</span>
<span class="sd">        nx.Graph: Undirected graph with areas as nodes and borders as edges.</span>
<span class="sd">            Graph may contain multiple disconnected components if areas</span>
<span class="sd">            are not fully interconnected.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; graph = generator.get_area_graph()</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Areas: {list(graph.nodes())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Borders: {list(graph.edges())}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Check connectivity</span>
<span class="sd">        &gt;&gt;&gt; connected = nx.is_connected(graph)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;All areas connected: {connected}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">borders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_borders</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span> <span class="ow">in</span> <span class="n">borders</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">graph</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.enhance_with_geometry" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">enhance_with_geometry</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_generator.AreaBorderModelGenerator.enhance_with_geometry" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">enhance_with_geometry</span><span class="p">(</span><span class="n">border_model_df</span><span class="p">:</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span><span class="p">,</span> <span class="n">area_geometry_calculator</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="            AreaBorderGeometryCalculator (mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator)" href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator">AreaBorderGeometryCalculator</a></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="pandas.DataFrame">DataFrame</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Enhance border model with geometric properties for visualization.</p>
<p>Integrates with AreaBorderGeometryCalculator to add geometric information
to borders, including representative points, directional angles, and
line geometries. This enables advanced visualization of energy system borders.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>border_model_df</code>
            </td>
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Border model DataFrame to enhance</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_geometry_calculator</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="            AreaBorderGeometryCalculator (mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator)" href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator">AreaBorderGeometryCalculator</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Configured geometry calculator with area
polygon data for geometric computations</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pd.DataFrame: Enhanced border model with additional geometric columns:
- projection_point: Point for label/arrow placement
- azimuth_angle: Directional angle in degrees
- is_physical: Boolean indicating if border is physical (touching areas)
- geo_line_string: LineString geometry representing the border</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # Setup geometry calculator with area polygons
&gt;&gt;&gt; geo_calc = AreaBorderGeometryCalculator(area_polygons_gdf)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Enhance border model
&gt;&gt;&gt; enhanced_borders = generator.enhance_with_geometry(border_model, geo_calc)
&gt;&gt;&gt; print(enhanced_borders.columns)  # Includes geometric properties
</code></pre></div>


<details class="note" open>
  <summary>Note</summary>
  <p>Geometric enhancement may fail for some borders due to missing
area geometries or calculation errors. Such failures are logged
as warnings without stopping the overall process.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_generator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">enhance_with_geometry</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">border_model_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">area_geometry_calculator</span><span class="p">:</span> <span class="n">AreaBorderGeometryCalculator</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhance border model with geometric properties for visualization.</span>

<span class="sd">    Integrates with AreaBorderGeometryCalculator to add geometric information</span>
<span class="sd">    to borders, including representative points, directional angles, and</span>
<span class="sd">    line geometries. This enables advanced visualization of energy system borders.</span>

<span class="sd">    Args:</span>
<span class="sd">        border_model_df: Border model DataFrame to enhance</span>
<span class="sd">        area_geometry_calculator: Configured geometry calculator with area</span>
<span class="sd">            polygon data for geometric computations</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Enhanced border model with additional geometric columns:</span>
<span class="sd">            - projection_point: Point for label/arrow placement</span>
<span class="sd">            - azimuth_angle: Directional angle in degrees</span>
<span class="sd">            - is_physical: Boolean indicating if border is physical (touching areas)</span>
<span class="sd">            - geo_line_string: LineString geometry representing the border</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; # Setup geometry calculator with area polygons</span>
<span class="sd">        &gt;&gt;&gt; geo_calc = AreaBorderGeometryCalculator(area_polygons_gdf)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Enhance border model</span>
<span class="sd">        &gt;&gt;&gt; enhanced_borders = generator.enhance_with_geometry(border_model, geo_calc)</span>
<span class="sd">        &gt;&gt;&gt; print(enhanced_borders.columns)  # Includes geometric properties</span>

<span class="sd">    Note:</span>
<span class="sd">        Geometric enhancement may fail for some borders due to missing</span>
<span class="sd">        area geometries or calculation errors. Such failures are logged</span>
<span class="sd">        as warnings without stopping the overall process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">enhanced_df</span> <span class="o">=</span> <span class="n">border_model_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">border_id</span><span class="p">,</span> <span class="n">border</span> <span class="ow">in</span> <span class="n">border_model_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">area_from</span> <span class="o">=</span> <span class="n">border</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source_area_identifier</span><span class="p">]</span>
        <span class="n">area_to</span> <span class="o">=</span> <span class="n">border</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target_area_identifier</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">geometry_info</span> <span class="o">=</span> <span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">calculate_border_geometry</span><span class="p">(</span>
                <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span>
            <span class="p">)</span>

            <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">border_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PROJECTION_POINT_IDENTIFIER</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry_info</span><span class="p">[</span><span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">PROJECTION_POINT_IDENTIFIER</span><span class="p">]</span>
            <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">border_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">AZIMUTH_ANGLE_IDENTIFIER</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry_info</span><span class="p">[</span><span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">AZIMUTH_ANGLE_IDENTIFIER</span><span class="p">]</span>
            <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">border_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BORDER_IS_PHYSICAL_IDENTIFIER</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry_info</span><span class="p">[</span><span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">BORDER_IS_PHYSICAL_IDENTIFIER</span><span class="p">]</span>
            <span class="n">enhanced_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">border_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BORDER_LINE_STRING_IDENTIFIER</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry_info</span><span class="p">[</span><span class="n">area_geometry_calculator</span><span class="o">.</span><span class="n">BORDER_LINE_STRING_IDENTIFIER</span><span class="p">]</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not calculate geometry for border </span><span class="si">{</span><span class="n">border_id</span><span class="si">}</span><span class="s2"> &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">area_from</span><span class="si">}</span><span class="s2"> → </span><span class="si">{</span><span class="n">area_to</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">enhanced_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>

<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">AreaBorderGeometryCalculator</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="            GeoModelGeneratorBase (mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase)" href="#mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase">GeoModelGeneratorBase</a></code></p>


        <p>Advanced geometric calculator for energy system area border analysis.</p>
<p>This class provides sophisticated geometric calculations for borders between
energy system areas, handling both physical borders (adjacent areas sharing
geographic boundaries) and logical borders (non-adjacent areas requiring
connection paths, e.g. through the sea). It's specifically designed to generate
properties for energy market cross-border visualizations.</p>
<p>The calculator combines multiple geometric algorithms:
- Physical border extraction using geometric intersection
- Logical geo-line-border path finding with obstacle avoidance
- Representative point computation using pole of inaccessibility for label placements on maps
- Azimuth angle calculation for flow icon (arrow) visualization
- Geometric validation and optimization</p>


<details class="key-features" open>
  <summary>Key Features</summary>
  <ul>
<li>Automatic detection of physical vs logical borders</li>
<li>Optimal path finding for non-crossing connections</li>
<li>Representative point calculation for label placement</li>
<li>Directional angle computation for arrow orientation</li>
<li>Performance optimization with geometric caching</li>
<li>Integration with MESCAL area accounting workflows</li>
</ul>
</details>

<details class="energy-domain-applications" open>
  <summary>Energy Domain Applications</summary>
  <ul>
<li>Visualization of cross-border (cross-country, cross-biddingzone, cross-macroregion) variables (flows, spreads, capacities, ...)</li>
</ul>
</details>

<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.area_model_gdf">area_model_gdf</span></code></td>
            <td>
                  <code><span title="geopandas.GeoDataFrame">GeoDataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>GeoDataFrame with area polygon geometries</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.non_crossing_path_finder">non_crossing_path_finder</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="            NonCrossingPathFinder (mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder)" href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder">NonCrossingPathFinder</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path optimization engine</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator._centroid_cache">_centroid_cache</span></code></td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Cached representative points for performance</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator._line_cache">_line_cache</span></code></td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Cached border lines for repeated calculations</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; import geopandas as gpd
&gt;&gt;&gt; from shapely.geometry import box
&gt;&gt;&gt; 
&gt;&gt;&gt; # Setup area geometries
&gt;&gt;&gt; areas = gpd.GeoDataFrame({
...     &#39;geometry&#39;: [box(0, 0, 1, 1), box(2, 0, 3, 1)]  # Two separate areas
... }, index=[&#39;Area_A&#39;, &#39;Area_B&#39;])
&gt;&gt;&gt; 
&gt;&gt;&gt; # Calculate border geometry
&gt;&gt;&gt; calculator = AreaBorderGeometryCalculator(areas)
&gt;&gt;&gt; border_info = calculator.calculate_border_geometry(&#39;Area_A&#39;, &#39;Area_B&#39;)
&gt;&gt;&gt; print(f&quot;Border type: {&#39;Physical&#39; if border_info[&#39;is_physical&#39;] else &#39;Logical&#39;}&quot;)
</code></pre></div>








              <details class="quote">
                <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AreaBorderGeometryCalculator</span><span class="p">(</span><span class="n">GeoModelGeneratorBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Advanced geometric calculator for energy system area border analysis.</span>

<span class="sd">    This class provides sophisticated geometric calculations for borders between</span>
<span class="sd">    energy system areas, handling both physical borders (adjacent areas sharing</span>
<span class="sd">    geographic boundaries) and logical borders (non-adjacent areas requiring</span>
<span class="sd">    connection paths, e.g. through the sea). It&#39;s specifically designed to generate</span>
<span class="sd">    properties for energy market cross-border visualizations.</span>

<span class="sd">    The calculator combines multiple geometric algorithms:</span>
<span class="sd">    - Physical border extraction using geometric intersection</span>
<span class="sd">    - Logical geo-line-border path finding with obstacle avoidance</span>
<span class="sd">    - Representative point computation using pole of inaccessibility for label placements on maps</span>
<span class="sd">    - Azimuth angle calculation for flow icon (arrow) visualization</span>
<span class="sd">    - Geometric validation and optimization</span>

<span class="sd">    Key Features:</span>
<span class="sd">        - Automatic detection of physical vs logical borders</span>
<span class="sd">        - Optimal path finding for non-crossing connections</span>
<span class="sd">        - Representative point calculation for label placement</span>
<span class="sd">        - Directional angle computation for arrow orientation</span>
<span class="sd">        - Performance optimization with geometric caching</span>
<span class="sd">        - Integration with MESCAL area accounting workflows</span>

<span class="sd">    Energy Domain Applications:</span>
<span class="sd">        - Visualization of cross-border (cross-country, cross-biddingzone, cross-macroregion) variables (flows, spreads, capacities, ...)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        area_model_gdf (gpd.GeoDataFrame): GeoDataFrame with area polygon geometries</span>
<span class="sd">        non_crossing_path_finder (NonCrossingPathFinder): Path optimization engine</span>
<span class="sd">        _centroid_cache (dict): Cached representative points for performance</span>
<span class="sd">        _line_cache (dict): Cached border lines for repeated calculations</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">        &gt;&gt;&gt; from shapely.geometry import box</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Setup area geometries</span>
<span class="sd">        &gt;&gt;&gt; areas = gpd.GeoDataFrame({</span>
<span class="sd">        ...     &#39;geometry&#39;: [box(0, 0, 1, 1), box(2, 0, 3, 1)]  # Two separate areas</span>
<span class="sd">        ... }, index=[&#39;Area_A&#39;, &#39;Area_B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Calculate border geometry</span>
<span class="sd">        &gt;&gt;&gt; calculator = AreaBorderGeometryCalculator(areas)</span>
<span class="sd">        &gt;&gt;&gt; border_info = calculator.calculate_border_geometry(&#39;Area_A&#39;, &#39;Area_B&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Border type: {&#39;Physical&#39; if border_info[&#39;is_physical&#39;] else &#39;Logical&#39;}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">PROJECTION_POINT_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;projection_point&#39;</span>
    <span class="n">AZIMUTH_ANGLE_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;azimuth_angle&#39;</span>
    <span class="n">BORDER_IS_PHYSICAL_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;is_physical&#39;</span>
    <span class="n">BORDER_LINE_STRING_IDENTIFIER</span> <span class="o">=</span> <span class="s1">&#39;geo_line_string&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_model_gdf</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">non_crossing_path_finder</span><span class="p">:</span> <span class="s1">&#39;NonCrossingPathFinder&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the border geometry calculator.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_model_gdf: GeoDataFrame containing area geometries with polygon</span>
<span class="sd">                boundaries. Index should contain area identifiers (e.g., country codes,</span>
<span class="sd">                bidding zone names). Must contain valid polygon geometries in &#39;geometry&#39; column.</span>
<span class="sd">            non_crossing_path_finder: Optional custom path finder for logical borders.</span>
<span class="sd">                If None, creates default NonCrossingPathFinder with standard parameters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If geometries are invalid or area_model_gdf lacks required structure</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; areas_gdf = gpd.read_file(&#39;countries.geojson&#39;).set_index(&#39;ISO_A2&#39;)</span>
<span class="sd">            &gt;&gt;&gt; calculator = AreaBorderGeometryCalculator(areas_gdf)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Custom path finder for specific requirements</span>
<span class="sd">            &gt;&gt;&gt; custom_finder = NonCrossingPathFinder(num_points=200, min_clearance=10000)</span>
<span class="sd">            &gt;&gt;&gt; calculator = AreaBorderGeometryCalculator(areas_gdf, custom_finder)</span>

<span class="sd">        Note:</span>
<span class="sd">            Invalid geometries are automatically cleaned using buffer(0) operation.</span>
<span class="sd">            Large area datasets benefit from using projected coordinate systems</span>
<span class="sd">            for accurate geometric calculations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_model_gdf</span> <span class="o">=</span> <span class="n">area_model_gdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_crossing_path_finder</span> <span class="o">=</span> <span class="n">non_crossing_path_finder</span> <span class="ow">or</span> <span class="n">NonCrossingPathFinder</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_geometries</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_centroid_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">LineString</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_geometries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate and clean area geometries for reliable calculations.</span>

<span class="sd">        Applies buffer(0) operation to fix invalid geometries (self-intersections,</span>
<span class="sd">        unclosed rings, etc.) that could cause calculation failures. This is</span>
<span class="sd">        particularly important for real-world geographic data that may have</span>
<span class="sd">        topology issues.</span>

<span class="sd">        Note:</span>
<span class="sd">            The buffer(0) operation is a common technique for fixing invalid</span>
<span class="sd">            polygon geometries without changing their fundamental shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_model_gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_model_gdf</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span> <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">is_valid</span> <span class="k">else</span> <span class="n">geom</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_border_geometry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
        <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate comprehensive geometric properties for an area border.</span>

<span class="sd">        This is the main interface method that computes all geometric properties</span>
<span class="sd">        needed for border visualization and analysis. It automatically detects</span>
<span class="sd">        whether areas are physically adjacent or logically connected and applies</span>
<span class="sd">        appropriate geometric algorithms.</span>

<span class="sd">        Processing Logic:</span>
<span class="sd">            1. Detect if areas share physical boundary (touching/intersecting)</span>
<span class="sd">            2. For physical borders: extract shared boundary line</span>
<span class="sd">            3. For logical borders: compute optimal connection path</span>
<span class="sd">            4. Calculate representative point for label/arrow placement</span>
<span class="sd">            5. Compute azimuth angle for arrow icon visualization</span>

<span class="sd">        Args:</span>
<span class="sd">            area_from: Source area identifier (must exist in area_model_gdf index)</span>
<span class="sd">            area_to: Target area identifier (must exist in area_model_gdf index)</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Comprehensive border geometry information containing:</span>
<span class="sd">                - &#39;projection_point&#39; (Point): Optimal point for label/arrow placement</span>
<span class="sd">                - &#39;azimuth_angle&#39; (float): Directional angle in degrees (0-360)</span>
<span class="sd">                - &#39;geo_line_string&#39; (LineString): Border line geometry</span>
<span class="sd">                - &#39;is_physical&#39; (bool): True for touching areas, False for logical borders</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: If area_from or area_to not found in area_model_gdf</span>
<span class="sd">            ValueError: If geometric calculations fail</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; border_info = calculator.calculate_border_geometry(&#39;DE&#39;, &#39;FR&#39;)</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; # Use for visualization</span>
<span class="sd">            &gt;&gt;&gt; point = border_info[&#39;projection_point&#39;]</span>
<span class="sd">            &gt;&gt;&gt; angle = border_info[&#39;azimuth_angle&#39;]</span>
<span class="sd">            &gt;&gt;&gt; is_physical = border_info[&#39;is_physical&#39;]</span>
<span class="sd">            &gt;&gt;&gt; </span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Border DE→FR: {point} at {angle}° ({&#39;physical&#39; if is_physical else &#39;logical&#39;})&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_border_midpoint_and_angle</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_touch</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_intersect</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
            <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">)</span>
            <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">)</span>
            <span class="n">border_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_continuous_border_line</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">geom_to</span><span class="p">)</span>
            <span class="n">is_physical</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">border_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_straight_line_between_areas</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>
            <span class="n">is_physical</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PROJECTION_POINT_IDENTIFIER</span><span class="p">:</span> <span class="n">midpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AZIMUTH_ANGLE_IDENTIFIER</span><span class="p">:</span> <span class="n">angle</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BORDER_LINE_STRING_IDENTIFIER</span><span class="p">:</span> <span class="n">border_line</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BORDER_IS_PHYSICAL_IDENTIFIER</span><span class="p">:</span> <span class="n">is_physical</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">areas_touch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if two areas share a common physical (geographic) border.</span>

<span class="sd">        Uses Shapely&#39;s touches() method to determine if area boundaries</span>
<span class="sd">        intersect without overlapping. This is the standard definition</span>
<span class="sd">        of physical adjacency for energy market regions.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_from: Source area identifier</span>
<span class="sd">            area_to: Target area identifier</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if areas share a common boundary, False otherwise</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; touching = calculator.areas_touch(&#39;DE&#39;, &#39;FR&#39;)  # True for neighboring countries</span>
<span class="sd">            &gt;&gt;&gt; separated = calculator.areas_touch(&#39;DE&#39;, &#39;GB&#39;)  # False for non-adjacent countries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">)</span>
        <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">geom_from</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">geom_to</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">areas_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if two areas have any geometric intersection.</span>

<span class="sd">        Uses Shapely&#39;s intersects() method to check for any form of geometric</span>
<span class="sd">        intersection, including touching, overlapping, or containment. This is</span>
<span class="sd">        broader than the touches() check and handles edge cases in geographic data.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_from: Source area identifier</span>
<span class="sd">            area_to: Target area identifier</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if areas have any geometric intersection, False otherwise</span>

<span class="sd">        Note:</span>
<span class="sd">            This method is used as a fallback for areas_touch() to handle</span>
<span class="sd">            geographic data with small overlaps or slight topology inconsistencies</span>
<span class="sd">            that are common in real-world boundary datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">)</span>
        <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">geom_from</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geom_to</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_area_border_midpoint_and_angle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> 
        <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
        <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate representative point and directional angle for border.</span>

<span class="sd">        Computes the optimal point for placing directional indicators (arrows,</span>
<span class="sd">        labels) and the corresponding angle for proper orientation. The algorithm</span>
<span class="sd">        adapts to both physical and logical borders to ensure optimal placement.</span>

<span class="sd">        For Physical Borders:</span>
<span class="sd">            - Uses midpoint of shared boundary line</span>
<span class="sd">            - Angle is perpendicular to boundary, pointing toward target area</span>

<span class="sd">        For Logical Borders:</span>
<span class="sd">            - Uses midpoint of optimal connection line</span>
<span class="sd">            - Angle follows connection direction from source to target</span>

<span class="sd">        Args:</span>
<span class="sd">            area_from: Source area identifier</span>
<span class="sd">            area_to: Target area identifier</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[Point, float]: Representative point and directional angle in degrees.</span>
<span class="sd">                Angle range: 0-360 degrees, where 0° is North, 90° is East.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; point, angle = calculator.get_area_border_midpoint_and_angle(&#39;DE&#39;, &#39;FR&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Place arrow at {point} oriented at {angle}° for DE→FR flow&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">)</span>
        <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_touch</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_intersect</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
            <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_midpoint_and_angle_for_touching_areas</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">geom_to</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">straight_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_straight_line_between_areas</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>
            <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_midpoint_and_angle_from_line</span><span class="p">(</span><span class="n">straight_line</span><span class="p">)</span>

        <span class="c1"># Ensure angle points from area_from to area_to</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angle_points_to_target</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">geom_to</span><span class="p">,</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">180</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>

        <span class="k">return</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_area_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve and validate geometry for a specified area.</span>

<span class="sd">        Args:</span>
<span class="sd">            area: Area identifier that must exist in area_model_gdf index</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[Polygon, MultiPolygon]: Cleaned geometry with buffer(0) applied</span>
<span class="sd">                to ensure validity for geometric operations</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: If area is not found in area_model_gdf</span>

<span class="sd">        Note:</span>
<span class="sd">            The buffer(0) operation ensures geometric validity for complex</span>
<span class="sd">            calculations, which is essential for reliable border analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_model_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_straight_line_between_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineString</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute optimal straight-line connection between non-adjacent areas.</span>

<span class="sd">        Creates a direct line connection between area boundaries, with intelligent</span>
<span class="sd">        path optimization to avoid crossing other areas when possible. This is</span>
<span class="sd">        particularly important for non-physical borders.</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Find representative points for both areas</span>
<span class="sd">            2. Create line connecting area centroids</span>
<span class="sd">            3. Calculate intersection points with area boundaries  </span>
<span class="sd">            4. Check for conflicts with other areas</span>
<span class="sd">            5. Apply non-crossing path optimization if needed</span>

<span class="sd">        Args:</span>
<span class="sd">            area_from: Source area identifier</span>
<span class="sd">            area_to: Target area identifier</span>

<span class="sd">        Returns:</span>
<span class="sd">            LineString: Optimized connection line between area boundaries.</span>
<span class="sd">                Line endpoints touch the area boundaries, not the centroids.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If areas are touching (should use physical border instead)</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; # Connect non-adjacent areas (e.g., Germany to UK)</span>
<span class="sd">            &gt;&gt;&gt; line = calculator.get_straight_line_between_areas(&#39;DE&#39;, &#39;GB&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Connection length: {line.length:.0f} km&quot;)</span>

<span class="sd">        Performance Note:</span>
<span class="sd">            Results are cached to improve performance for repeated calculations.</span>
<span class="sd">            Path optimization can be computationally intensive for complex geometries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_touch</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Areas </span><span class="si">{</span><span class="n">area_from</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">area_to</span><span class="si">}</span><span class="s2"> touch - use border line instead&quot;</span><span class="p">)</span>

        <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_largest_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">))</span>
        <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_largest_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">))</span>

        <span class="n">centroid_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representative_area_point</span><span class="p">(</span><span class="n">geom_from</span><span class="p">)</span>
        <span class="n">centroid_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representative_area_point</span><span class="p">(</span><span class="n">geom_to</span><span class="p">)</span>

        <span class="n">line_full</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([</span><span class="n">centroid_from</span><span class="p">,</span> <span class="n">centroid_to</span><span class="p">])</span>

        <span class="c1"># Find intersection points with area boundaries</span>
        <span class="n">intersection_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_boundary_intersection</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">line_full</span><span class="p">,</span> <span class="n">centroid_to</span><span class="p">)</span>
        <span class="n">intersection_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_boundary_intersection</span><span class="p">(</span><span class="n">geom_to</span><span class="p">,</span> <span class="n">line_full</span><span class="p">,</span> <span class="n">centroid_from</span><span class="p">)</span>

        <span class="n">straight_line</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([</span><span class="n">intersection_from</span><span class="p">,</span> <span class="n">intersection_to</span><span class="p">])</span>

        <span class="c1"># Check if line crosses other areas</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_crosses_other_areas</span><span class="p">(</span><span class="n">straight_line</span><span class="p">,</span> <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
            <span class="c1"># Try to find alternative path</span>
            <span class="n">better_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_non_crossing_line</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">better_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">straight_line</span> <span class="o">=</span> <span class="n">better_line</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_line_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">straight_line</span>
        <span class="k">return</span> <span class="n">straight_line</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_midpoint_and_angle_for_touching_areas</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_from</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">],</span>
        <span class="n">geom_to</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate midpoint and angle for physically adjacent areas.</span>

<span class="sd">        For areas that share a physical boundary, this method extracts the</span>
<span class="sd">        shared border line and computes the optimal point and angle for</span>
<span class="sd">        directional indicators.</span>

<span class="sd">        Args:</span>
<span class="sd">            geom_from: Source area geometry</span>
<span class="sd">            geom_to: Target area geometry</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[Point, float]: Midpoint of shared border and perpendicular angle</span>
<span class="sd">                pointing from source toward target area</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Extract continuous border line from geometric intersection</span>
<span class="sd">            2. Find midpoint along border line (50% interpolation)</span>
<span class="sd">            3. Calculate border bearing and perpendicular angle</span>
<span class="sd">            4. Ensure angle points from source to target area</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">border_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_continuous_border_line</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">geom_to</span><span class="p">)</span>
        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">border_line</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get angle perpendicular to border</span>
        <span class="n">start_to_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_straight_line_from_endpoints</span><span class="p">(</span><span class="n">border_line</span><span class="p">)</span>
        <span class="n">border_bearing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_bearing</span><span class="p">(</span><span class="n">start_to_end</span><span class="p">)</span>
        <span class="n">perpendicular_angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">border_bearing</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>

        <span class="k">return</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">perpendicular_angle</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_midpoint_and_angle_from_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">LineString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract midpoint and directional angle from a LineString.</span>

<span class="sd">        Args:</span>
<span class="sd">            line: Input LineString geometry</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[Point, float]: Midpoint and bearing angle in degrees</span>

<span class="sd">        Note:</span>
<span class="sd">            Uses 50% interpolation to find the midpoint, ensuring consistent</span>
<span class="sd">            positioning regardless of coordinate density along the line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_bearing</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_angle_points_to_target</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_from</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">],</span>
        <span class="n">geom_to</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">],</span>
        <span class="n">midpoint</span><span class="p">:</span> <span class="n">Point</span><span class="p">,</span>
        <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate that computed angle points from source toward target area.</span>

<span class="sd">        Ensures directional consistency by checking if the angle points closer</span>
<span class="sd">        to the target area than to the source area. This is essential for</span>
<span class="sd">        correct arrow orientation in energy flow visualization.</span>

<span class="sd">        Args:</span>
<span class="sd">            geom_from: Source area geometry</span>
<span class="sd">            geom_to: Target area geometry  </span>
<span class="sd">            midpoint: Reference point for angle measurement</span>
<span class="sd">            angle: Angle to validate (in degrees)</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if angle points toward target, False if it points toward source</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Calculate bearings from midpoint to both area centroids</span>
<span class="sd">            2. Compute angular differences between proposed angle and both bearings</span>
<span class="sd">            3. Return True if angle is closer to target bearing than source bearing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centroid_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representative_area_point</span><span class="p">(</span><span class="n">geom_from</span><span class="p">)</span>
        <span class="n">centroid_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representative_area_point</span><span class="p">(</span><span class="n">geom_to</span><span class="p">)</span>

        <span class="n">bearing_to_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_bearing</span><span class="p">(</span><span class="n">LineString</span><span class="p">([</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">centroid_from</span><span class="p">]))</span>
        <span class="n">bearing_to_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_bearing</span><span class="p">(</span><span class="n">LineString</span><span class="p">([</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">centroid_to</span><span class="p">]))</span>

        <span class="n">angle_diff_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angular_difference</span><span class="p">(</span><span class="n">bearing_to_from</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">angle_diff_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angular_difference</span><span class="p">(</span><span class="n">bearing_to_to</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">angle_diff_to</span> <span class="o">&lt;</span> <span class="n">angle_diff_from</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_continuous_border_line</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">],</span>
        <span class="n">geom_b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineString</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract shared boundary line between touching geometries.</span>

<span class="sd">        Computes the geometric intersection between two touching areas and</span>
<span class="sd">        converts the result into a continuous LineString representing the</span>
<span class="sd">        shared border. Handles complex intersection geometries including</span>
<span class="sd">        multiple segments and mixed geometry types.</span>

<span class="sd">        Args:</span>
<span class="sd">            geom_a: First area geometry</span>
<span class="sd">            geom_b: Second area geometry</span>

<span class="sd">        Returns:</span>
<span class="sd">            LineString: Continuous line representing the shared boundary</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If geometries don&#39;t touch or intersect</span>
<span class="sd">            TypeError: If intersection cannot be converted to LineString</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Compute geometric intersection of the two areas</span>
<span class="sd">            2. Handle GeometryCollection by extracting line components</span>
<span class="sd">            3. Convert Polygon boundaries to LineString if needed</span>
<span class="sd">            4. Merge multiple LineStrings into continuous representation</span>
<span class="sd">            5. Handle MultiLineString by connecting segments optimally</span>

<span class="sd">        Note:</span>
<span class="sd">            This method handles the complexity of real-world geographic boundaries</span>
<span class="sd">            which may result in complex intersection geometries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the shared border between two touching geometries.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">geom_a</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">geom_b</span><span class="p">)</span> <span class="ow">or</span> <span class="n">geom_a</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geom_b</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Geometries do not touch or intersect&quot;</span><span class="p">)</span>

        <span class="n">border</span> <span class="o">=</span> <span class="n">geom_a</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">geom_b</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">border</span><span class="p">,</span> <span class="n">GeometryCollection</span><span class="p">):</span>
            <span class="n">extracted_lines</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">border</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">LineString</span><span class="p">):</span>
                    <span class="n">extracted_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
                    <span class="n">extracted_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">):</span>
                    <span class="n">extracted_lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">geoms</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                    <span class="n">extracted_lines</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">boundary</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">geoms</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">extracted_lines</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GeometryCollection could not be converted into line: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">border</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">border</span> <span class="o">=</span> <span class="n">linemerge</span><span class="p">(</span><span class="n">extracted_lines</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">border</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
            <span class="n">border</span> <span class="o">=</span> <span class="n">linemerge</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">boundary</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">border</span><span class="o">.</span><span class="n">geoms</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">border</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="n">border</span> <span class="o">=</span> <span class="n">border</span><span class="o">.</span><span class="n">boundary</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">border</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">):</span>
            <span class="n">border</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_multilinestring</span><span class="p">(</span><span class="n">border</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">border</span><span class="p">,</span> <span class="n">LineString</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">border</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected border type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">border</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_boundary_intersection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom</span><span class="p">:</span> <span class="n">Polygon</span><span class="p">,</span>
        <span class="n">line</span><span class="p">:</span> <span class="n">LineString</span><span class="p">,</span>
        <span class="n">target_point</span><span class="p">:</span> <span class="n">Point</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Point</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find optimal intersection point between line and polygon boundary.</span>

<span class="sd">        When a line intersects a polygon boundary at multiple points, this method</span>
<span class="sd">        selects the point that is closest to a specified target point. This is</span>
<span class="sd">        essential for creating clean border connections.</span>

<span class="sd">        Args:</span>
<span class="sd">            geom: Polygon whose boundary to intersect with</span>
<span class="sd">            line: LineString to intersect with polygon boundary</span>
<span class="sd">            target_point: Reference point for choosing among multiple intersections</span>

<span class="sd">        Returns:</span>
<span class="sd">            Point: Intersection point closest to target_point</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If intersection geometry type is unexpected</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Compute intersection between line and polygon boundary</span>
<span class="sd">            2. Handle different intersection geometry types (Point, MultiPoint, LineString)</span>
<span class="sd">            3. For multiple options, select point closest to target</span>
<span class="sd">            4. Extract coordinates and create Point geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find where a line intersects a polygon boundary, choosing the point closest to target.&quot;&quot;&quot;</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">intersection</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="n">MultiPoint</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">intersection</span><span class="o">.</span><span class="n">geoms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">target_point</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">)):</span>
            <span class="c1"># Get all coordinates and find closest</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="n">LineString</span><span class="p">):</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">intersection</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">intersection</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
                    <span class="n">coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">coords</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">target_point</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected intersection type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_line_crosses_other_areas</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">line</span><span class="p">:</span> <span class="n">LineString</span><span class="p">,</span>
        <span class="o">*</span><span class="n">exclude_areas</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a line crosses through any areas except specified exclusions.</span>

<span class="sd">        This method is crucial for validating logical border connections to ensure</span>
<span class="sd">        they don&#39;t inappropriately cross through other energy market areas, which</span>
<span class="sd">        would be misleading in visualization.</span>

<span class="sd">        Args:</span>
<span class="sd">            line: LineString to test for crossings</span>
<span class="sd">            *exclude_areas: Area identifiers to exclude from crossing check</span>
<span class="sd">                (typically the source and target areas of the line)</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if line crosses any non-excluded areas, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_model_gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">exclude_areas</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">other_areas</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">crosses</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_non_crossing_line</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find optimal connection path that avoids crossing other areas.</span>

<span class="sd">        Uses the NonCrossingPathFinder to compute the shortest connection between</span>
<span class="sd">        two areas that maintains minimum clearance from other areas. This creates</span>
<span class="sd">        clean visualization paths for logical borders.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_from: Source area identifier</span>
<span class="sd">            area_to: Target area identifier</span>

<span class="sd">        Returns:</span>
<span class="sd">            LineString or None: Optimal non-crossing path, or None if no suitable</span>
<span class="sd">                path found within the configured constraints</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Extract largest polygons from MultiPolygon geometries</span>
<span class="sd">            2. Create exclusion set of all other areas</span>
<span class="sd">            3. Apply NonCrossingPathFinder algorithm</span>
<span class="sd">            4. Return shortest valid path or None if impossible</span>

<span class="sd">        Performance Note:</span>
<span class="sd">            This operation can be computationally intensive for complex geometries</span>
<span class="sd">            and large numbers of areas. Results are cached for efficiency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poly_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_largest_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">))</span>
        <span class="n">poly_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_largest_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_crossing_path_finder</span><span class="o">.</span><span class="n">find_shortest_path</span><span class="p">(</span>
            <span class="n">poly_from</span><span class="p">,</span>
            <span class="n">poly_to</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">area_model_gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">]),</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">area_from</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">area_to</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_largest_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Polygon</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract largest polygon component from MultiPolygon geometry.</span>

<span class="sd">        For MultiPolygon geometries (e.g., countries with islands), this method</span>
<span class="sd">        returns the largest polygon by area, which is typically the main landmass.</span>
<span class="sd">        This simplifies calculations while focusing on the most significant</span>
<span class="sd">        geographic component.</span>

<span class="sd">        Args:</span>
<span class="sd">            geom: Input geometry (Polygon returned as-is, MultiPolygon simplified)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Polygon: Largest polygon component by area</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">geom</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_multilinestring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mls</span><span class="p">:</span> <span class="n">MultiLineString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineString</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge disconnected LineString segments into continuous line.</span>

<span class="sd">        Converts a MultiLineString into a single continuous LineString by</span>
<span class="sd">        intelligently connecting segments to minimize total length while</span>
<span class="sd">        preserving the overall geometric relationship.</span>

<span class="sd">        Args:</span>
<span class="sd">            mls: MultiLineString with potentially disconnected segments</span>

<span class="sd">        Returns:</span>
<span class="sd">            LineString: Continuous line connecting all segments optimally</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Attempt automatic merge using Shapely&#39;s linemerge</span>
<span class="sd">            2. If segments remain disconnected, apply iterative connection:</span>
<span class="sd">               - Find closest pair of segment endpoints</span>
<span class="sd">               - Connect segments with optimal orientation</span>
<span class="sd">               - Repeat until single continuous line achieved</span>

<span class="sd">        Note:</span>
<span class="sd">            This method is particularly important for complex international</span>
<span class="sd">            borders that may be represented as multiple disconnected segments</span>
<span class="sd">            in geographic datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">linemerge</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mls</span><span class="o">.</span><span class="n">geoms</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">merged</span><span class="p">,</span> <span class="n">LineString</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">merged</span>

        <span class="c1"># Connect disconnected segments</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">merged</span><span class="o">.</span><span class="n">geoms</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Find closest pair</span>
            <span class="n">min_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
            <span class="n">closest_pair</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">line2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">nearest_points</span><span class="p">(</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">)</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist</span>
                        <span class="n">closest_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

            <span class="c1"># Connect closest pair</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">closest_pair</span>
            <span class="n">line1</span><span class="p">,</span> <span class="n">line2</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lines</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># Create connected line</span>
            <span class="n">coords1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">line1</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">line2</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

            <span class="c1"># Find best connection direction</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">coords1</span> <span class="o">+</span> <span class="n">coords2</span><span class="p">,</span> <span class="n">LineString</span><span class="p">(</span><span class="n">coords1</span> <span class="o">+</span> <span class="n">coords2</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
                <span class="p">(</span><span class="n">coords1</span> <span class="o">+</span> <span class="n">coords2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">LineString</span><span class="p">(</span><span class="n">coords1</span> <span class="o">+</span> <span class="n">coords2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
                <span class="p">(</span><span class="n">coords1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coords2</span><span class="p">,</span> <span class="n">LineString</span><span class="p">(</span><span class="n">coords1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coords2</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
                <span class="p">(</span><span class="n">coords1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coords2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">LineString</span><span class="p">(</span><span class="n">coords1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coords2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">best_coords</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">new_line</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">best_coords</span><span class="p">)</span>

            <span class="c1"># Update lines list</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_line</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_straight_line_from_endpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">LineString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineString</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create straight line connecting first and last coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            line: Input LineString with potentially complex path</span>

<span class="sd">        Returns:</span>
<span class="sd">            LineString: Simplified straight line from start to end</span>

<span class="sd">        Use Case:</span>
<span class="sd">            Useful for computing bearing angles from complex border geometries</span>
<span class="sd">            by simplifying to the fundamental start-to-end direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LineString</span><span class="p">([</span><span class="n">line</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_bearing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">LineString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate compass bearing (Azimuth angle) for a LineString.</span>

<span class="sd">        Args:</span>
<span class="sd">            line: LineString from which to calculate bearing</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Compass bearing (Azimuth angle) in degrees (0-360)</span>
<span class="sd">                - 0° = North</span>
<span class="sd">                - 90° = East  </span>
<span class="sd">                - 180° = South</span>
<span class="sd">                - 270° = West</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            Uses the forward azimuth formula from geodetic calculations:</span>
<span class="sd">            1. Convert coordinates to radians</span>
<span class="sd">            2. Apply spherical trigonometry formulas</span>
<span class="sd">            3. Convert result to compass bearing (0-360°)</span>

<span class="sd">        Note:</span>
<span class="sd">            This implementation assumes coordinates are in geographic (lat/lon)</span>
<span class="sd">            format. For projected coordinates, results approximate true bearings</span>
<span class="sd">            within reasonable accuracy for visualization purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">lat1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lat2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">diff_lon</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">diff_lon</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">-</span> 
             <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">diff_lon</span><span class="p">))</span>

        <span class="n">bearing</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">bearing</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span>
        <span class="n">compass_bearing</span> <span class="o">=</span> <span class="p">(</span><span class="n">bearing</span> <span class="o">+</span> <span class="mi">360</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>

        <span class="k">return</span> <span class="n">compass_bearing</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_angular_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">angle2</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate minimum angular difference between two compass bearings.</span>

<span class="sd">        Handles the circular nature of compass bearings to find the shortest</span>
<span class="sd">        angular distance between two directions, accounting for the 0°/360° wraparound.</span>

<span class="sd">        Args:</span>
<span class="sd">            angle1: First angle in degrees (0-360)</span>
<span class="sd">            angle2: Second angle in degrees (0-360)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Minimum angular difference in degrees (0-180)</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; diff = calculator._angular_difference(10, 350)  # Returns 20, not 340</span>
<span class="sd">            &gt;&gt;&gt; diff = calculator._angular_difference(90, 270)  # Returns 180</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle1</span> <span class="o">-</span> <span class="n">angle2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">360</span> <span class="o">-</span> <span class="n">diff</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.__init__" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">__init__</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.__init__" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">__init__</span><span class="p">(</span><span class="n">area_model_gdf</span><span class="p">:</span> <span class="n"><span title="geopandas.GeoDataFrame">GeoDataFrame</span></span><span class="p">,</span> <span class="n">non_crossing_path_finder</span><span class="p">:</span> <span class="n"><a class="autorefs autorefs-internal" title="            NonCrossingPathFinder (mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder)" href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder">NonCrossingPathFinder</a></span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Initialize the border geometry calculator.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_model_gdf</code>
            </td>
            <td>
                  <code><span title="geopandas.GeoDataFrame">GeoDataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>GeoDataFrame containing area geometries with polygon
boundaries. Index should contain area identifiers (e.g., country codes,
bidding zone names). Must contain valid polygon geometries in 'geometry' column.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>non_crossing_path_finder</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="            NonCrossingPathFinder (mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder)" href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder">NonCrossingPathFinder</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Optional custom path finder for logical borders.
If None, creates default NonCrossingPathFinder with standard parameters.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If geometries are invalid or area_model_gdf lacks required structure</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; areas_gdf = gpd.read_file(&#39;countries.geojson&#39;).set_index(&#39;ISO_A2&#39;)
&gt;&gt;&gt; calculator = AreaBorderGeometryCalculator(areas_gdf)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Custom path finder for specific requirements
&gt;&gt;&gt; custom_finder = NonCrossingPathFinder(num_points=200, min_clearance=10000)
&gt;&gt;&gt; calculator = AreaBorderGeometryCalculator(areas_gdf, custom_finder)
</code></pre></div>


<details class="note" open>
  <summary>Note</summary>
  <p>Invalid geometries are automatically cleaned using buffer(0) operation.
Large area datasets benefit from using projected coordinate systems
for accurate geometric calculations.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span>
<span class="normal">98</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_model_gdf</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">non_crossing_path_finder</span><span class="p">:</span> <span class="s1">&#39;NonCrossingPathFinder&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the border geometry calculator.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_model_gdf: GeoDataFrame containing area geometries with polygon</span>
<span class="sd">            boundaries. Index should contain area identifiers (e.g., country codes,</span>
<span class="sd">            bidding zone names). Must contain valid polygon geometries in &#39;geometry&#39; column.</span>
<span class="sd">        non_crossing_path_finder: Optional custom path finder for logical borders.</span>
<span class="sd">            If None, creates default NonCrossingPathFinder with standard parameters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If geometries are invalid or area_model_gdf lacks required structure</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; areas_gdf = gpd.read_file(&#39;countries.geojson&#39;).set_index(&#39;ISO_A2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; calculator = AreaBorderGeometryCalculator(areas_gdf)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Custom path finder for specific requirements</span>
<span class="sd">        &gt;&gt;&gt; custom_finder = NonCrossingPathFinder(num_points=200, min_clearance=10000)</span>
<span class="sd">        &gt;&gt;&gt; calculator = AreaBorderGeometryCalculator(areas_gdf, custom_finder)</span>

<span class="sd">    Note:</span>
<span class="sd">        Invalid geometries are automatically cleaned using buffer(0) operation.</span>
<span class="sd">        Large area datasets benefit from using projected coordinate systems</span>
<span class="sd">        for accurate geometric calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">area_model_gdf</span> <span class="o">=</span> <span class="n">area_model_gdf</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">non_crossing_path_finder</span> <span class="o">=</span> <span class="n">non_crossing_path_finder</span> <span class="ow">or</span> <span class="n">NonCrossingPathFinder</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_validate_geometries</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_centroid_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Point</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_line_cache</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">LineString</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.calculate_border_geometry" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">calculate_border_geometry</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.calculate_border_geometry" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">calculate_border_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="dict">dict</span></span><span class="p">[</span><span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n"><span title="typing.Union">Union</span></span><span class="p">[</span><span class="n"><span title="shapely.geometry.Point">Point</span></span><span class="p">,</span> <span class="n"><span title="float">float</span></span><span class="p">,</span> <span class="n"><span title="shapely.geometry.LineString">LineString</span></span><span class="p">,</span> <span class="n"><span title="bool">bool</span></span><span class="p">]]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Calculate comprehensive geometric properties for an area border.</p>
<p>This is the main interface method that computes all geometric properties
needed for border visualization and analysis. It automatically detects
whether areas are physically adjacent or logically connected and applies
appropriate geometric algorithms.</p>


<details class="processing-logic" open>
  <summary>Processing Logic</summary>
  <ol>
<li>Detect if areas share physical boundary (touching/intersecting)</li>
<li>For physical borders: extract shared boundary line</li>
<li>For logical borders: compute optimal connection path</li>
<li>Calculate representative point for label/arrow placement</li>
<li>Compute azimuth angle for arrow icon visualization</li>
</ol>
</details>

<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_from</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Source area identifier (must exist in area_model_gdf index)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_to</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target area identifier (must exist in area_model_gdf index)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>dict</code></td>            <td>
                  <code><span title="dict">dict</span>[<span title="str">str</span>, <span title="typing.Union">Union</span>[<span title="shapely.geometry.Point">Point</span>, <span title="float">float</span>, <span title="shapely.geometry.LineString">LineString</span>, <span title="bool">bool</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Comprehensive border geometry information containing:
- 'projection_point' (Point): Optimal point for label/arrow placement
- 'azimuth_angle' (float): Directional angle in degrees (0-360)
- 'geo_line_string' (LineString): Border line geometry
- 'is_physical' (bool): True for touching areas, False for logical borders</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="KeyError">KeyError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If area_from or area_to not found in area_model_gdf</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If geometric calculations fail</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; border_info = calculator.calculate_border_geometry(&#39;DE&#39;, &#39;FR&#39;)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Use for visualization
&gt;&gt;&gt; point = border_info[&#39;projection_point&#39;]
&gt;&gt;&gt; angle = border_info[&#39;azimuth_angle&#39;]
&gt;&gt;&gt; is_physical = border_info[&#39;is_physical&#39;]
&gt;&gt;&gt; 
&gt;&gt;&gt; print(f&quot;Border DE→FR: {point} at {angle}° ({&#39;physical&#39; if is_physical else &#39;logical&#39;})&quot;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">calculate_border_geometry</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
    <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate comprehensive geometric properties for an area border.</span>

<span class="sd">    This is the main interface method that computes all geometric properties</span>
<span class="sd">    needed for border visualization and analysis. It automatically detects</span>
<span class="sd">    whether areas are physically adjacent or logically connected and applies</span>
<span class="sd">    appropriate geometric algorithms.</span>

<span class="sd">    Processing Logic:</span>
<span class="sd">        1. Detect if areas share physical boundary (touching/intersecting)</span>
<span class="sd">        2. For physical borders: extract shared boundary line</span>
<span class="sd">        3. For logical borders: compute optimal connection path</span>
<span class="sd">        4. Calculate representative point for label/arrow placement</span>
<span class="sd">        5. Compute azimuth angle for arrow icon visualization</span>

<span class="sd">    Args:</span>
<span class="sd">        area_from: Source area identifier (must exist in area_model_gdf index)</span>
<span class="sd">        area_to: Target area identifier (must exist in area_model_gdf index)</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Comprehensive border geometry information containing:</span>
<span class="sd">            - &#39;projection_point&#39; (Point): Optimal point for label/arrow placement</span>
<span class="sd">            - &#39;azimuth_angle&#39; (float): Directional angle in degrees (0-360)</span>
<span class="sd">            - &#39;geo_line_string&#39; (LineString): Border line geometry</span>
<span class="sd">            - &#39;is_physical&#39; (bool): True for touching areas, False for logical borders</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: If area_from or area_to not found in area_model_gdf</span>
<span class="sd">        ValueError: If geometric calculations fail</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; border_info = calculator.calculate_border_geometry(&#39;DE&#39;, &#39;FR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Use for visualization</span>
<span class="sd">        &gt;&gt;&gt; point = border_info[&#39;projection_point&#39;]</span>
<span class="sd">        &gt;&gt;&gt; angle = border_info[&#39;azimuth_angle&#39;]</span>
<span class="sd">        &gt;&gt;&gt; is_physical = border_info[&#39;is_physical&#39;]</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Border DE→FR: {point} at {angle}° ({&#39;physical&#39; if is_physical else &#39;logical&#39;})&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_border_midpoint_and_angle</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_touch</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_intersect</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
        <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">)</span>
        <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">)</span>
        <span class="n">border_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_continuous_border_line</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">geom_to</span><span class="p">)</span>
        <span class="n">is_physical</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">border_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_straight_line_between_areas</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>
        <span class="n">is_physical</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PROJECTION_POINT_IDENTIFIER</span><span class="p">:</span> <span class="n">midpoint</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AZIMUTH_ANGLE_IDENTIFIER</span><span class="p">:</span> <span class="n">angle</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BORDER_LINE_STRING_IDENTIFIER</span><span class="p">:</span> <span class="n">border_line</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BORDER_IS_PHYSICAL_IDENTIFIER</span><span class="p">:</span> <span class="n">is_physical</span>
    <span class="p">}</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.areas_touch" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">areas_touch</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.areas_touch" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">areas_touch</span><span class="p">(</span><span class="n">area_from</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="bool">bool</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Check if two areas share a common physical (geographic) border.</p>
<p>Uses Shapely's touches() method to determine if area boundaries
intersect without overlapping. This is the standard definition
of physical adjacency for energy market regions.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_from</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Source area identifier</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_to</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target area identifier</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>bool</code></td>            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>True if areas share a common boundary, False otherwise</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; touching = calculator.areas_touch(&#39;DE&#39;, &#39;FR&#39;)  # True for neighboring countries
&gt;&gt;&gt; separated = calculator.areas_touch(&#39;DE&#39;, &#39;GB&#39;)  # False for non-adjacent countries
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">areas_touch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if two areas share a common physical (geographic) border.</span>

<span class="sd">    Uses Shapely&#39;s touches() method to determine if area boundaries</span>
<span class="sd">    intersect without overlapping. This is the standard definition</span>
<span class="sd">    of physical adjacency for energy market regions.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_from: Source area identifier</span>
<span class="sd">        area_to: Target area identifier</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if areas share a common boundary, False otherwise</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; touching = calculator.areas_touch(&#39;DE&#39;, &#39;FR&#39;)  # True for neighboring countries</span>
<span class="sd">        &gt;&gt;&gt; separated = calculator.areas_touch(&#39;DE&#39;, &#39;GB&#39;)  # False for non-adjacent countries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">)</span>
    <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">geom_from</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">geom_to</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.areas_intersect" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">areas_intersect</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.areas_intersect" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">areas_intersect</span><span class="p">(</span><span class="n">area_from</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="bool">bool</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Check if two areas have any geometric intersection.</p>
<p>Uses Shapely's intersects() method to check for any form of geometric
intersection, including touching, overlapping, or containment. This is
broader than the touches() check and handles edge cases in geographic data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_from</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Source area identifier</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_to</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target area identifier</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>bool</code></td>            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>True if areas have any geometric intersection, False otherwise</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <p>This method is used as a fallback for areas_touch() to handle
geographic data with small overlaps or slight topology inconsistencies
that are common in real-world boundary datasets.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">areas_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if two areas have any geometric intersection.</span>

<span class="sd">    Uses Shapely&#39;s intersects() method to check for any form of geometric</span>
<span class="sd">    intersection, including touching, overlapping, or containment. This is</span>
<span class="sd">    broader than the touches() check and handles edge cases in geographic data.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_from: Source area identifier</span>
<span class="sd">        area_to: Target area identifier</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if areas have any geometric intersection, False otherwise</span>

<span class="sd">    Note:</span>
<span class="sd">        This method is used as a fallback for areas_touch() to handle</span>
<span class="sd">        geographic data with small overlaps or slight topology inconsistencies</span>
<span class="sd">        that are common in real-world boundary datasets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">)</span>
    <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">geom_from</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geom_to</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_area_border_midpoint_and_angle" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_area_border_midpoint_and_angle</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_area_border_midpoint_and_angle" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_area_border_midpoint_and_angle</span><span class="p">(</span><span class="n">area_from</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="tuple">tuple</span></span><span class="p">[</span><span class="n"><span title="shapely.geometry.Point">Point</span></span><span class="p">,</span> <span class="n"><span title="float">float</span></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Calculate representative point and directional angle for border.</p>
<p>Computes the optimal point for placing directional indicators (arrows,
labels) and the corresponding angle for proper orientation. The algorithm
adapts to both physical and logical borders to ensure optimal placement.</p>


<details class="for-physical-borders" open>
  <summary>For Physical Borders</summary>
  <ul>
<li>Uses midpoint of shared boundary line</li>
<li>Angle is perpendicular to boundary, pointing toward target area</li>
</ul>
</details>

<details class="for-logical-borders" open>
  <summary>For Logical Borders</summary>
  <ul>
<li>Uses midpoint of optimal connection line</li>
<li>Angle follows connection direction from source to target</li>
</ul>
</details>

<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_from</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Source area identifier</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_to</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target area identifier</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="tuple">tuple</span>[<span title="shapely.geometry.Point">Point</span>, <span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple[Point, float]: Representative point and directional angle in degrees.
Angle range: 0-360 degrees, where 0° is North, 90° is East.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; point, angle = calculator.get_area_border_midpoint_and_angle(&#39;DE&#39;, &#39;FR&#39;)
&gt;&gt;&gt; print(f&quot;Place arrow at {point} oriented at {angle}° for DE→FR flow&quot;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_area_border_midpoint_and_angle</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
    <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate representative point and directional angle for border.</span>

<span class="sd">    Computes the optimal point for placing directional indicators (arrows,</span>
<span class="sd">    labels) and the corresponding angle for proper orientation. The algorithm</span>
<span class="sd">    adapts to both physical and logical borders to ensure optimal placement.</span>

<span class="sd">    For Physical Borders:</span>
<span class="sd">        - Uses midpoint of shared boundary line</span>
<span class="sd">        - Angle is perpendicular to boundary, pointing toward target area</span>

<span class="sd">    For Logical Borders:</span>
<span class="sd">        - Uses midpoint of optimal connection line</span>
<span class="sd">        - Angle follows connection direction from source to target</span>

<span class="sd">    Args:</span>
<span class="sd">        area_from: Source area identifier</span>
<span class="sd">        area_to: Target area identifier</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[Point, float]: Representative point and directional angle in degrees.</span>
<span class="sd">            Angle range: 0-360 degrees, where 0° is North, 90° is East.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; point, angle = calculator.get_area_border_midpoint_and_angle(&#39;DE&#39;, &#39;FR&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Place arrow at {point} oriented at {angle}° for DE→FR flow&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">)</span>
    <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_touch</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_intersect</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
        <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_midpoint_and_angle_for_touching_areas</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">geom_to</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">straight_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_straight_line_between_areas</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>
        <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_midpoint_and_angle_from_line</span><span class="p">(</span><span class="n">straight_line</span><span class="p">)</span>

    <span class="c1"># Ensure angle points from area_from to area_to</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angle_points_to_target</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">geom_to</span><span class="p">,</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="mi">180</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>

    <span class="k">return</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">angle</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_area_geometry" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_area_geometry</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_area_geometry" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_area_geometry</span><span class="p">(</span><span class="n">area</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="typing.Union">Union</span></span><span class="p">[</span><span class="n"><span title="shapely.geometry.Polygon">Polygon</span></span><span class="p">,</span> <span class="n"><span title="shapely.geometry.MultiPolygon">MultiPolygon</span></span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Retrieve and validate geometry for a specified area.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Area identifier that must exist in area_model_gdf index</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="shapely.geometry.Polygon">Polygon</span>, <span title="shapely.geometry.MultiPolygon">MultiPolygon</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Union[Polygon, MultiPolygon]: Cleaned geometry with buffer(0) applied
to ensure validity for geometric operations</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="KeyError">KeyError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If area is not found in area_model_gdf</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <p>The buffer(0) operation ensures geometric validity for complex
calculations, which is essential for reliable border analysis.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_area_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Retrieve and validate geometry for a specified area.</span>

<span class="sd">    Args:</span>
<span class="sd">        area: Area identifier that must exist in area_model_gdf index</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[Polygon, MultiPolygon]: Cleaned geometry with buffer(0) applied</span>
<span class="sd">            to ensure validity for geometric operations</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: If area is not found in area_model_gdf</span>

<span class="sd">    Note:</span>
<span class="sd">        The buffer(0) operation ensures geometric validity for complex</span>
<span class="sd">        calculations, which is essential for reliable border analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_model_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">area</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_straight_line_between_areas" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_straight_line_between_areas</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.AreaBorderGeometryCalculator.get_straight_line_between_areas" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_straight_line_between_areas</span><span class="p">(</span><span class="n">area_from</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="n"><span title="str">str</span></span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="shapely.geometry.LineString">LineString</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Compute optimal straight-line connection between non-adjacent areas.</p>
<p>Creates a direct line connection between area boundaries, with intelligent
path optimization to avoid crossing other areas when possible. This is
particularly important for non-physical borders.</p>


<details class="algorithm" open>
  <summary>Algorithm</summary>
  <ol>
<li>Find representative points for both areas</li>
<li>Create line connecting area centroids</li>
<li>Calculate intersection points with area boundaries  </li>
<li>Check for conflicts with other areas</li>
<li>Apply non-crossing path optimization if needed</li>
</ol>
</details>

<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>area_from</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Source area identifier</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>area_to</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target area identifier</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>LineString</code></td>            <td>
                  <code><span title="shapely.geometry.LineString">LineString</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Optimized connection line between area boundaries.
Line endpoints touch the area boundaries, not the centroids.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If areas are touching (should use physical border instead)</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # Connect non-adjacent areas (e.g., Germany to UK)
&gt;&gt;&gt; line = calculator.get_straight_line_between_areas(&#39;DE&#39;, &#39;GB&#39;)
&gt;&gt;&gt; print(f&quot;Connection length: {line.length:.0f} km&quot;)
</code></pre></div>


<details class="performance-note" open>
  <summary>Performance Note</summary>
  <p>Results are cached to improve performance for repeated calculations.
Path optimization can be computationally intensive for complex geometries.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_straight_line_between_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_from</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">area_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineString</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute optimal straight-line connection between non-adjacent areas.</span>

<span class="sd">    Creates a direct line connection between area boundaries, with intelligent</span>
<span class="sd">    path optimization to avoid crossing other areas when possible. This is</span>
<span class="sd">    particularly important for non-physical borders.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">        1. Find representative points for both areas</span>
<span class="sd">        2. Create line connecting area centroids</span>
<span class="sd">        3. Calculate intersection points with area boundaries  </span>
<span class="sd">        4. Check for conflicts with other areas</span>
<span class="sd">        5. Apply non-crossing path optimization if needed</span>

<span class="sd">    Args:</span>
<span class="sd">        area_from: Source area identifier</span>
<span class="sd">        area_to: Target area identifier</span>

<span class="sd">    Returns:</span>
<span class="sd">        LineString: Optimized connection line between area boundaries.</span>
<span class="sd">            Line endpoints touch the area boundaries, not the centroids.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If areas are touching (should use physical border instead)</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; # Connect non-adjacent areas (e.g., Germany to UK)</span>
<span class="sd">        &gt;&gt;&gt; line = calculator.get_straight_line_between_areas(&#39;DE&#39;, &#39;GB&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Connection length: {line.length:.0f} km&quot;)</span>

<span class="sd">    Performance Note:</span>
<span class="sd">        Results are cached to improve performance for repeated calculations.</span>
<span class="sd">        Path optimization can be computationally intensive for complex geometries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">areas_touch</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Areas </span><span class="si">{</span><span class="n">area_from</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">area_to</span><span class="si">}</span><span class="s2"> touch - use border line instead&quot;</span><span class="p">)</span>

    <span class="n">geom_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_largest_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_from</span><span class="p">))</span>
    <span class="n">geom_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_largest_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_area_geometry</span><span class="p">(</span><span class="n">area_to</span><span class="p">))</span>

    <span class="n">centroid_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representative_area_point</span><span class="p">(</span><span class="n">geom_from</span><span class="p">)</span>
    <span class="n">centroid_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_representative_area_point</span><span class="p">(</span><span class="n">geom_to</span><span class="p">)</span>

    <span class="n">line_full</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([</span><span class="n">centroid_from</span><span class="p">,</span> <span class="n">centroid_to</span><span class="p">])</span>

    <span class="c1"># Find intersection points with area boundaries</span>
    <span class="n">intersection_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_boundary_intersection</span><span class="p">(</span><span class="n">geom_from</span><span class="p">,</span> <span class="n">line_full</span><span class="p">,</span> <span class="n">centroid_to</span><span class="p">)</span>
    <span class="n">intersection_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_boundary_intersection</span><span class="p">(</span><span class="n">geom_to</span><span class="p">,</span> <span class="n">line_full</span><span class="p">,</span> <span class="n">centroid_from</span><span class="p">)</span>

    <span class="n">straight_line</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([</span><span class="n">intersection_from</span><span class="p">,</span> <span class="n">intersection_to</span><span class="p">])</span>

    <span class="c1"># Check if line crosses other areas</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_crosses_other_areas</span><span class="p">(</span><span class="n">straight_line</span><span class="p">,</span> <span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">):</span>
        <span class="c1"># Try to find alternative path</span>
        <span class="n">better_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_non_crossing_line</span><span class="p">(</span><span class="n">area_from</span><span class="p">,</span> <span class="n">area_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">better_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">straight_line</span> <span class="o">=</span> <span class="n">better_line</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_line_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">straight_line</span>
    <span class="k">return</span> <span class="n">straight_line</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">NonCrossingPathFinder</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">


        <p>Optimized path finder for non-crossing connections between areas.</p>
<p>This class implements an algorithm for finding the shortest
path between two polygon areas while maintaining specified clearance from
other areas. It's specifically designed for energy system visualization
where geographic border line representations should not misleadingly
cross through other market areas.</p>
<p>The algorithm uses a brute-force approach to test multiple potential paths
and select the optimal solution.</p>


<details class="key-features" open>
  <summary>Key Features</summary>
  <ul>
<li>Configurable boundary point sampling density</li>
<li>Adjustable minimum clearance distances</li>
<li>Progress tracking for long-running operations</li>
<li>Optimization for common geometric scenarios</li>
</ul>
</details>

<details class="performance-characteristics" open>
  <summary>Performance Characteristics</summary>
  <ul>
<li>Time complexity: O(n² × m) where n=num_points, m=number of other areas</li>
<li>Memory usage scales with point sampling density</li>
<li>Results improve with higher point sampling but at computational cost</li>
</ul>
</details>

<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.num_points">num_points</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of boundary points to sample per area</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.min_clearance">min_clearance</span></code></td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Minimum distance from other areas (in CRS units)</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.show_progress">show_progress</span></code></td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to display progress bars for long operations</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # High-precision path finding
&gt;&gt;&gt; finder = NonCrossingPathFinder(num_points=500, min_clearance=50000)
&gt;&gt;&gt; path = finder.find_shortest_path(area1_poly, area2_poly, other_areas_gdf)
</code></pre></div>








              <details class="quote">
                <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span>
<span class="normal">958</span>
<span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span>
<span class="normal">984</span>
<span class="normal">985</span>
<span class="normal">986</span>
<span class="normal">987</span>
<span class="normal">988</span>
<span class="normal">989</span>
<span class="normal">990</span>
<span class="normal">991</span>
<span class="normal">992</span>
<span class="normal">993</span>
<span class="normal">994</span>
<span class="normal">995</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">NonCrossingPathFinder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optimized path finder for non-crossing connections between areas.</span>

<span class="sd">    This class implements an algorithm for finding the shortest</span>
<span class="sd">    path between two polygon areas while maintaining specified clearance from</span>
<span class="sd">    other areas. It&#39;s specifically designed for energy system visualization</span>
<span class="sd">    where geographic border line representations should not misleadingly</span>
<span class="sd">    cross through other market areas.</span>

<span class="sd">    The algorithm uses a brute-force approach to test multiple potential paths</span>
<span class="sd">    and select the optimal solution.</span>

<span class="sd">    Key Features:</span>
<span class="sd">        - Configurable boundary point sampling density</span>
<span class="sd">        - Adjustable minimum clearance distances</span>
<span class="sd">        - Progress tracking for long-running operations</span>
<span class="sd">        - Optimization for common geometric scenarios</span>

<span class="sd">    Performance Characteristics:</span>
<span class="sd">        - Time complexity: O(n² × m) where n=num_points, m=number of other areas</span>
<span class="sd">        - Memory usage scales with point sampling density</span>
<span class="sd">        - Results improve with higher point sampling but at computational cost</span>

<span class="sd">    Attributes:</span>
<span class="sd">        num_points (int): Number of boundary points to sample per area</span>
<span class="sd">        min_clearance (float): Minimum distance from other areas (in CRS units)</span>
<span class="sd">        show_progress (bool): Whether to display progress bars for long operations</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; # High-precision path finding</span>
<span class="sd">        &gt;&gt;&gt; finder = NonCrossingPathFinder(num_points=500, min_clearance=50000)</span>
<span class="sd">        &gt;&gt;&gt; path = finder.find_shortest_path(area1_poly, area2_poly, other_areas_gdf)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">min_clearance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the non-crossing path finder.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_points: Number of boundary points to sample per polygon.</span>
<span class="sd">                Higher values improve path quality but increase computation time.</span>
<span class="sd">                Typical range: 50-500 depending on precision requirements.</span>
<span class="sd">            min_clearance: Minimum clearance distance from other areas in</span>
<span class="sd">                coordinate reference system units. For geographic coordinates,</span>
<span class="sd">                this is typically in meters when using projected CRS.</span>
<span class="sd">            show_progress: Whether to display progress bars during computation.</span>
<span class="sd">                Useful for long-running operations with high num_points values.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; # High-precision finder for detailed analysis</span>
<span class="sd">            &gt;&gt;&gt; finder = NonCrossingPathFinder(</span>
<span class="sd">            ...     num_points=300,      # High sampling density</span>
<span class="sd">            ...     min_clearance=25000, # 25km minimum clearance</span>
<span class="sd">            ...     show_progress=True   # Show progress for long operations</span>
<span class="sd">            ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span> <span class="o">=</span> <span class="n">num_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_clearance</span> <span class="o">=</span> <span class="n">min_clearance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_progress</span> <span class="o">=</span> <span class="n">show_progress</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find_shortest_path</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">polygon1</span><span class="p">:</span> <span class="n">Polygon</span><span class="p">,</span>
        <span class="n">polygon2</span><span class="p">:</span> <span class="n">Polygon</span><span class="p">,</span>
        <span class="n">other_areas</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find shortest non-crossing path between two polygons.</span>

<span class="sd">        Tests all combinations of boundary points between two polygons to find</span>
<span class="sd">        the shortest connection that maintains minimum clearance from other areas.</span>
<span class="sd">        If the algorithm succeedes and finds a non-crossing LineString, it ensures</span>
<span class="sd">        clean visualization paths for energy market border analysis.</span>

<span class="sd">        Args:</span>
<span class="sd">            polygon1: Source polygon geometry</span>
<span class="sd">            polygon2: Target polygon geometry</span>
<span class="sd">            other_areas: GeoDataFrame of areas to avoid crossing through</span>
<span class="sd">            name: Optional name for progress tracking display</span>

<span class="sd">        Returns:</span>
<span class="sd">            LineString or None: Shortest valid path between polygons, or None</span>
<span class="sd">                if no path meets clearance requirements</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Sample boundary points for both polygons</span>
<span class="sd">            2. Buffer other areas by minimum clearance distance</span>
<span class="sd">            3. Test all point-to-point connections</span>
<span class="sd">            4. Filter out paths that cross buffered areas</span>
<span class="sd">            5. Return shortest valid path</span>

<span class="sd">        Performance Scaling:</span>
<span class="sd">            - Total paths tested: num_points² </span>
<span class="sd">            - With default num_points=100: tests 10,000 potential paths</span>
<span class="sd">            - Computation time scales roughly O(n² × m) where m = number of other areas</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; path = finder.find_shortest_path(</span>
<span class="sd">            ...     source_area, target_area, obstacles_gdf, &quot;Germany to UK&quot;</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; if path:</span>
<span class="sd">            ...     print(f&quot;Found path with length: {path.length:.0f} meters&quot;)</span>
<span class="sd">            ... else:</span>
<span class="sd">            ...     print(&quot;No valid path found with current clearance settings&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buffered_areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_areas</span><span class="p">(</span><span class="n">other_areas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_clearance</span><span class="p">)</span>
        <span class="n">points1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_boundary_points</span><span class="p">(</span><span class="n">polygon1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>
        <span class="n">points2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_boundary_points</span><span class="p">(</span><span class="n">polygon2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">LineString</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">])</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">)]</span>
        <span class="n">shortest_line</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">min_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

        <span class="n">iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Finding path for </span><span class="si">{</span><span class="n">name</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s1">&#39;path&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_progress</span> <span class="k">else</span> <span class="n">lines</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">buffered_areas</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">crosses</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
                    <span class="n">shortest_line</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">min_length</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span>

        <span class="k">return</span> <span class="n">shortest_line</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_buffer_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">areas</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span> <span class="n">buffer_distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply buffer operation to create clearance zones around areas.</span>

<span class="sd">        Creates expanded geometries around areas to enforce minimum clearance</span>
<span class="sd">        distances. Handles coordinate system transformations to ensure accurate</span>
<span class="sd">        distance-based buffering regardless of input CRS.</span>

<span class="sd">        Args:</span>
<span class="sd">            areas: GeoDataFrame containing areas to buffer</span>
<span class="sd">            buffer_distance: Buffer distance in meters</span>

<span class="sd">        Returns:</span>
<span class="sd">            gpd.GeoDataFrame: Areas with buffered geometries in original CRS</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If GeoDataFrame lacks valid CRS definition</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Check if CRS is geographic (lat/lon)</span>
<span class="sd">            2. If geographic, temporarily project to Web Mercator (EPSG:3857)</span>
<span class="sd">            3. Apply buffer operation in projected coordinates</span>
<span class="sd">            4. Transform back to original CRS</span>
<span class="sd">            5. If already projected, buffer directly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">areas_copy</span> <span class="o">=</span> <span class="n">areas</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">original_crs</span> <span class="o">=</span> <span class="n">areas_copy</span><span class="o">.</span><span class="n">crs</span>

        <span class="k">if</span> <span class="n">original_crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;GeoDataFrame must have a valid CRS defined.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">original_crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
            <span class="c1"># Use Web Mercator for accurate distance-based buffering</span>
            <span class="n">projected_crs</span> <span class="o">=</span> <span class="s2">&quot;EPSG:3857&quot;</span>
            <span class="n">areas_copy</span> <span class="o">=</span> <span class="n">areas_copy</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">projected_crs</span><span class="p">)</span>
            <span class="n">areas_copy</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areas_copy</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_distance</span><span class="p">)</span>
            <span class="n">areas_copy</span> <span class="o">=</span> <span class="n">areas_copy</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">original_crs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Already in projected coordinates</span>
            <span class="n">areas_copy</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">areas_copy</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_distance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">areas_copy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_boundary_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample evenly distributed points along polygon boundary.</span>

<span class="sd">        Creates a uniform sampling of points along the polygon perimeter using</span>
<span class="sd">        interpolation. This provides comprehensive coverage for path-finding</span>
<span class="sd">        while maintaining computational efficiency.</span>

<span class="sd">        Args:</span>
<span class="sd">            polygon: Input polygon to sample</span>
<span class="sd">            num_points: Number of points to sample along boundary</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Point]: List of evenly spaced boundary points</span>

<span class="sd">        Algorithm:</span>
<span class="sd">            1. Calculate total boundary length</span>
<span class="sd">            2. Divide into equal segments</span>
<span class="sd">            3. Interpolate points at regular intervals</span>
<span class="sd">            4. Return as list of Point geometries</span>

<span class="sd">        Note:</span>
<span class="sd">            Points are distributed proportionally to boundary length,</span>
<span class="sd">            ensuring uniform density regardless of polygon complexity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boundary</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="n">boundary</span><span class="o">.</span><span class="n">length</span>
        <span class="c1"># Generate evenly spaced points along boundary</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">boundary</span><span class="o">.</span><span class="n">interpolate</span><span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="n">num_points</span><span class="p">)</span> <span class="o">*</span> <span class="n">total_length</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">)]</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.__init__" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">__init__</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.__init__" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">__init__</span><span class="p">(</span><span class="n">num_points</span><span class="p">:</span> <span class="n"><span title="int">int</span></span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">min_clearance</span><span class="p">:</span> <span class="n"><span title="float">float</span></span> <span class="o">=</span> <span class="mi">50000</span><span class="p">,</span> <span class="n">show_progress</span><span class="p">:</span> <span class="n"><span title="bool">bool</span></span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Initialize the non-crossing path finder.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>num_points</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of boundary points to sample per polygon.
Higher values improve path quality but increase computation time.
Typical range: 50-500 depending on precision requirements.</p>
              </div>
            </td>
            <td>
                  <code>100</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>min_clearance</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Minimum clearance distance from other areas in
coordinate reference system units. For geographic coordinates,
this is typically in meters when using projected CRS.</p>
              </div>
            </td>
            <td>
                  <code>50000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>show_progress</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to display progress bars during computation.
Useful for long-running operations with high num_points values.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; # High-precision finder for detailed analysis
&gt;&gt;&gt; finder = NonCrossingPathFinder(
...     num_points=300,      # High sampling density
...     min_clearance=25000, # 25km minimum clearance
...     show_progress=True   # Show progress for long operations
... )
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">min_clearance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">,</span>
    <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the non-crossing path finder.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_points: Number of boundary points to sample per polygon.</span>
<span class="sd">            Higher values improve path quality but increase computation time.</span>
<span class="sd">            Typical range: 50-500 depending on precision requirements.</span>
<span class="sd">        min_clearance: Minimum clearance distance from other areas in</span>
<span class="sd">            coordinate reference system units. For geographic coordinates,</span>
<span class="sd">            this is typically in meters when using projected CRS.</span>
<span class="sd">        show_progress: Whether to display progress bars during computation.</span>
<span class="sd">            Useful for long-running operations with high num_points values.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; # High-precision finder for detailed analysis</span>
<span class="sd">        &gt;&gt;&gt; finder = NonCrossingPathFinder(</span>
<span class="sd">        ...     num_points=300,      # High sampling density</span>
<span class="sd">        ...     min_clearance=25000, # 25km minimum clearance</span>
<span class="sd">        ...     show_progress=True   # Show progress for long operations</span>
<span class="sd">        ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span> <span class="o">=</span> <span class="n">num_points</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">min_clearance</span> <span class="o">=</span> <span class="n">min_clearance</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">show_progress</span> <span class="o">=</span> <span class="n">show_progress</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.find_shortest_path" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">find_shortest_path</span>


<a href="#mescal.energy_data_handling.area_accounting.border_model_geometry_calculator.NonCrossingPathFinder.find_shortest_path" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">find_shortest_path</span><span class="p">(</span><span class="n">polygon1</span><span class="p">:</span> <span class="n"><span title="shapely.geometry.Polygon">Polygon</span></span><span class="p">,</span> <span class="n">polygon2</span><span class="p">:</span> <span class="n"><span title="shapely.geometry.Polygon">Polygon</span></span><span class="p">,</span> <span class="n">other_areas</span><span class="p">:</span> <span class="n"><span title="geopandas.GeoDataFrame">GeoDataFrame</span></span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n"><span title="str">str</span></span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n"><span title="typing.Union">Union</span></span><span class="p">[</span><span class="n"><span title="shapely.geometry.LineString">LineString</span></span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Find shortest non-crossing path between two polygons.</p>
<p>Tests all combinations of boundary points between two polygons to find
the shortest connection that maintains minimum clearance from other areas.
If the algorithm succeedes and finds a non-crossing LineString, it ensures
clean visualization paths for energy market border analysis.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>polygon1</code>
            </td>
            <td>
                  <code><span title="shapely.geometry.Polygon">Polygon</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Source polygon geometry</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>polygon2</code>
            </td>
            <td>
                  <code><span title="shapely.geometry.Polygon">Polygon</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target polygon geometry</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>other_areas</code>
            </td>
            <td>
                  <code><span title="geopandas.GeoDataFrame">GeoDataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>GeoDataFrame of areas to avoid crossing through</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Optional name for progress tracking display</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="shapely.geometry.LineString">LineString</span>, None]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>LineString or None: Shortest valid path between polygons, or None
if no path meets clearance requirements</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="algorithm" open>
  <summary>Algorithm</summary>
  <ol>
<li>Sample boundary points for both polygons</li>
<li>Buffer other areas by minimum clearance distance</li>
<li>Test all point-to-point connections</li>
<li>Filter out paths that cross buffered areas</li>
<li>Return shortest valid path</li>
</ol>
</details>

<details class="performance-scaling" open>
  <summary>Performance Scaling</summary>
  <ul>
<li>Total paths tested: num_points² </li>
<li>With default num_points=100: tests 10,000 potential paths</li>
<li>Computation time scales roughly O(n² × m) where m = number of other areas</li>
</ul>
</details>        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; path = finder.find_shortest_path(
...     source_area, target_area, obstacles_gdf, &quot;Germany to UK&quot;
... )
&gt;&gt;&gt; if path:
...     print(f&quot;Found path with length: {path.length:.0f} meters&quot;)
... else:
...     print(&quot;No valid path found with current clearance settings&quot;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/border_model_geometry_calculator.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_shortest_path</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">polygon1</span><span class="p">:</span> <span class="n">Polygon</span><span class="p">,</span>
    <span class="n">polygon2</span><span class="p">:</span> <span class="n">Polygon</span><span class="p">,</span>
    <span class="n">other_areas</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find shortest non-crossing path between two polygons.</span>

<span class="sd">    Tests all combinations of boundary points between two polygons to find</span>
<span class="sd">    the shortest connection that maintains minimum clearance from other areas.</span>
<span class="sd">    If the algorithm succeedes and finds a non-crossing LineString, it ensures</span>
<span class="sd">    clean visualization paths for energy market border analysis.</span>

<span class="sd">    Args:</span>
<span class="sd">        polygon1: Source polygon geometry</span>
<span class="sd">        polygon2: Target polygon geometry</span>
<span class="sd">        other_areas: GeoDataFrame of areas to avoid crossing through</span>
<span class="sd">        name: Optional name for progress tracking display</span>

<span class="sd">    Returns:</span>
<span class="sd">        LineString or None: Shortest valid path between polygons, or None</span>
<span class="sd">            if no path meets clearance requirements</span>

<span class="sd">    Algorithm:</span>
<span class="sd">        1. Sample boundary points for both polygons</span>
<span class="sd">        2. Buffer other areas by minimum clearance distance</span>
<span class="sd">        3. Test all point-to-point connections</span>
<span class="sd">        4. Filter out paths that cross buffered areas</span>
<span class="sd">        5. Return shortest valid path</span>

<span class="sd">    Performance Scaling:</span>
<span class="sd">        - Total paths tested: num_points² </span>
<span class="sd">        - With default num_points=100: tests 10,000 potential paths</span>
<span class="sd">        - Computation time scales roughly O(n² × m) where m = number of other areas</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; path = finder.find_shortest_path(</span>
<span class="sd">        ...     source_area, target_area, obstacles_gdf, &quot;Germany to UK&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; if path:</span>
<span class="sd">        ...     print(f&quot;Found path with length: {path.length:.0f} meters&quot;)</span>
<span class="sd">        ... else:</span>
<span class="sd">        ...     print(&quot;No valid path found with current clearance settings&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">buffered_areas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_areas</span><span class="p">(</span><span class="n">other_areas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_clearance</span><span class="p">)</span>
    <span class="n">points1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_boundary_points</span><span class="p">(</span><span class="n">polygon1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>
    <span class="n">points2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_boundary_points</span><span class="p">(</span><span class="n">polygon2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>

    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">LineString</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">])</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">)]</span>
    <span class="n">shortest_line</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">min_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

    <span class="n">iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Finding path for </span><span class="si">{</span><span class="n">name</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="s1">&#39;path&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_progress</span> <span class="k">else</span> <span class="n">lines</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">buffered_areas</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">crosses</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
                <span class="n">shortest_line</span> <span class="o">=</span> <span class="n">line</span>
                <span class="n">min_length</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span>

    <span class="k">return</span> <span class="n">shortest_line</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>

<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>            <span class="doc doc-object-name doc-class-name">GeoModelGeneratorBase</span>


<a href="#mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">


        <p>Base class for generating geometric models with representative points.</p>
<p>This class provides common functionality for working with geometric representations
of energy system areas, including methods for computing representative points
within polygons and multipolygons. It's designed to support energy market
analysis where spatial aggregation of nodes into areas is required.</p>
<p>The class supports two methods for computing representative points:
- 'polylabel': Uses pole of inaccessibility algorithm for optimal label placement
- 'representative_point': Uses Shapely's built-in representative point method</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase.REPRESENTATIVE_POINT_METHOD">REPRESENTATIVE_POINT_METHOD</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Method used for computing representative
points ('polylabel' or 'representative_point')</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase._polylabel_cache">_polylabel_cache</span></code></td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Cache for expensive polylabel calculations</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/model_generator_base.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  7</span>
<span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">GeoModelGeneratorBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for generating geometric models with representative points.</span>

<span class="sd">    This class provides common functionality for working with geometric representations</span>
<span class="sd">    of energy system areas, including methods for computing representative points</span>
<span class="sd">    within polygons and multipolygons. It&#39;s designed to support energy market</span>
<span class="sd">    analysis where spatial aggregation of nodes into areas is required.</span>

<span class="sd">    The class supports two methods for computing representative points:</span>
<span class="sd">    - &#39;polylabel&#39;: Uses pole of inaccessibility algorithm for optimal label placement</span>
<span class="sd">    - &#39;representative_point&#39;: Uses Shapely&#39;s built-in representative point method</span>

<span class="sd">    Attributes:</span>
<span class="sd">        REPRESENTATIVE_POINT_METHOD (str): Method used for computing representative</span>
<span class="sd">            points (&#39;polylabel&#39; or &#39;representative_point&#39;)</span>
<span class="sd">        _polylabel_cache (dict): Cache for expensive polylabel calculations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">REPRESENTATIVE_POINT_METHOD</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;polylabel&#39;</span><span class="p">,</span> <span class="s1">&#39;representative_point&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;polylabel&#39;</span>
    <span class="n">_polylabel_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_representative_area_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Point</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a representative point for a polygon or multipolygon geometry.</span>

<span class="sd">        This method computes a point that is guaranteed to be inside the geometry</span>
<span class="sd">        and is suitable for label placement or other visualization purposes in</span>
<span class="sd">        energy system maps. For MultiPolygons, it operates on the largest constituent.</span>

<span class="sd">        Args:</span>
<span class="sd">            geom: A Shapely Polygon or MultiPolygon geometry representing an</span>
<span class="sd">                energy system area (e.g., bidding zone, market region)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Point: A Shapely Point guaranteed to be inside the input geometry,</span>
<span class="sd">                suitable for map labels or representative location analysis</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If REPRESENTATIVE_POINT_METHOD is not supported</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; from shapely.geometry import Polygon, Point</span>
<span class="sd">            &gt;&gt;&gt; generator = GeoModelGeneratorBase()</span>
<span class="sd">            &gt;&gt;&gt; area_polygon = Polygon([(0, 0), (10, 0), (10, 10), (0, 10)])</span>
<span class="sd">            &gt;&gt;&gt; rep_point = generator.get_representative_area_point(area_polygon)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Representative point: {rep_point.x:.2f}, {rep_point.y:.2f}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">REPRESENTATIVE_POINT_METHOD</span> <span class="o">==</span> <span class="s1">&#39;polylabel&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_polylabel_point</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">REPRESENTATIVE_POINT_METHOD</span> <span class="o">==</span> <span class="s1">&#39;representative_point&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">representative_point</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;REPRESENTATIVE_POINT_METHOD </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">REPRESENTATIVE_POINT_METHOD</span><span class="si">}</span><span class="s1"> not supported&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_polylabel_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Point</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute representative point using the polylabel algorithm.</span>

<span class="sd">        The polylabel algorithm finds the pole of inaccessibility - the most distant</span>
<span class="sd">        internal point from the polygon outline. This is particularly useful for</span>
<span class="sd">        placing labels on complex energy system area geometries.</span>

<span class="sd">        For MultiPolygons, operates on the largest polygon by area, which is</span>
<span class="sd">        typically the main landmass for country/region representations.</span>

<span class="sd">        Args:</span>
<span class="sd">            geom: A Shapely Polygon or MultiPolygon geometry</span>

<span class="sd">        Returns:</span>
<span class="sd">            Point: The pole of inaccessibility point, cached for performance</span>

<span class="sd">        Note:</span>
<span class="sd">            Results are cached using the geometry&#39;s WKT representation as key.</span>
<span class="sd">            The precision parameter (1.0) provides good balance between accuracy</span>
<span class="sd">            and performance for typical energy system area sizes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">wkt</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polylabel_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polylabel_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">geoms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

        <span class="n">exterior</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">geom</span><span class="o">.</span><span class="n">interiors</span><span class="p">]</span>
        <span class="n">rings</span> <span class="o">=</span> <span class="p">[</span><span class="n">exterior</span><span class="p">]</span> <span class="o">+</span> <span class="n">holes</span>

        <span class="n">point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">polylabel</span><span class="p">(</span><span class="n">rings</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polylabel_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">return</span> <span class="n">point</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_representative_point_from_cloud_of_2d_points</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Point</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Point</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute geometric centroid from a collection of 2D points.</span>

<span class="sd">        This method is particularly useful in energy systems analysis for computing</span>
<span class="sd">        representative locations of energy assets (e.g., power plants, substations)</span>
<span class="sd">        that belong to the same area or region.</span>

<span class="sd">        The algorithm adapts based on the number of input points:</span>
<span class="sd">        - 1 point: Returns the point itself</span>
<span class="sd">        - 2 points: Returns the midpoint</span>
<span class="sd">        - ≥3 points: Computes convex hull and returns polygon centroid</span>

<span class="sd">        Args:</span>
<span class="sd">            points: List of Shapely Point objects representing energy asset</span>
<span class="sd">                locations or other spatial features within an area</span>

<span class="sd">        Returns:</span>
<span class="sd">            Point: Representative point for the collection of input points</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the input list is empty</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; from shapely.geometry import Point</span>
<span class="sd">            &gt;&gt;&gt; power_plants = [Point(1, 1), Point(3, 2), Point(2, 4)]</span>
<span class="sd">            &gt;&gt;&gt; centroid = GeoModelGeneratorBase._compute_representative_point_from_cloud_of_2d_points(power_plants)</span>
<span class="sd">            &gt;&gt;&gt; print(f&quot;Regional centroid: {centroid.x:.2f}, {centroid.y:.2f}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConvexHull</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty point list provided - cannot compute representative point&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Point</span><span class="p">((</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># For 3+ points, compute convex hull and return centroid</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
        <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">hull_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">hull_coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">polygon</span><span class="o">.</span><span class="n">representative_point</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase.get_representative_area_point" class="doc doc-heading">
<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>            <span class="doc doc-object-name doc-function-name">get_representative_area_point</span>


<a href="#mescal.energy_data_handling.area_accounting.model_generator_base.GeoModelGeneratorBase.get_representative_area_point" class="headerlink" title="Permanent link">&para;</a></h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_representative_area_point</span><span class="p">(</span><span class="n">geom</span><span class="p">:</span> <span class="n"><span title="typing.Union">Union</span></span><span class="p">[</span><span class="n"><span title="shapely.Polygon">Polygon</span></span><span class="p">,</span> <span class="n"><span title="shapely.MultiPolygon">MultiPolygon</span></span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n"><span title="shapely.Point">Point</span></span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Get a representative point for a polygon or multipolygon geometry.</p>
<p>This method computes a point that is guaranteed to be inside the geometry
and is suitable for label placement or other visualization purposes in
energy system maps. For MultiPolygons, it operates on the largest constituent.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>geom</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="shapely.Polygon">Polygon</span>, <span title="shapely.MultiPolygon">MultiPolygon</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A Shapely Polygon or MultiPolygon geometry representing an
energy system area (e.g., bidding zone, market region)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Point</code></td>            <td>
                  <code><span title="shapely.Point">Point</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A Shapely Point guaranteed to be inside the input geometry,
suitable for map labels or representative location analysis</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If REPRESENTATIVE_POINT_METHOD is not supported</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Example:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; from shapely.geometry import Polygon, Point
&gt;&gt;&gt; generator = GeoModelGeneratorBase()
&gt;&gt;&gt; area_polygon = Polygon([(0, 0), (10, 0), (10, 10), (0, 10)])
&gt;&gt;&gt; rep_point = generator.get_representative_area_point(area_polygon)
&gt;&gt;&gt; print(f&quot;Representative point: {rep_point.x:.2f}, {rep_point.y:.2f}&quot;)
</code></pre></div>


            <details class="quote">
              <summary>Source code in <code>submodules/mescal/mescal/energy_data_handling/area_accounting/model_generator_base.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_representative_area_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Point</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a representative point for a polygon or multipolygon geometry.</span>

<span class="sd">    This method computes a point that is guaranteed to be inside the geometry</span>
<span class="sd">    and is suitable for label placement or other visualization purposes in</span>
<span class="sd">    energy system maps. For MultiPolygons, it operates on the largest constituent.</span>

<span class="sd">    Args:</span>
<span class="sd">        geom: A Shapely Polygon or MultiPolygon geometry representing an</span>
<span class="sd">            energy system area (e.g., bidding zone, market region)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Point: A Shapely Point guaranteed to be inside the input geometry,</span>
<span class="sd">            suitable for map labels or representative location analysis</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If REPRESENTATIVE_POINT_METHOD is not supported</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; from shapely.geometry import Polygon, Point</span>
<span class="sd">        &gt;&gt;&gt; generator = GeoModelGeneratorBase()</span>
<span class="sd">        &gt;&gt;&gt; area_polygon = Polygon([(0, 0), (10, 0), (10, 10), (0, 10)])</span>
<span class="sd">        &gt;&gt;&gt; rep_point = generator.get_representative_area_point(area_polygon)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Representative point: {rep_point.x:.2f}, {rep_point.y:.2f}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">REPRESENTATIVE_POINT_METHOD</span> <span class="o">==</span> <span class="s1">&#39;polylabel&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_polylabel_point</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">REPRESENTATIVE_POINT_METHOD</span> <span class="o">==</span> <span class="s1">&#39;representative_point&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">representative_point</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;REPRESENTATIVE_POINT_METHOD </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">REPRESENTATIVE_POINT_METHOD</span><span class="si">}</span><span class="s1"> not supported&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../../../..", "features": ["navigation.tabs", "content.tabs.link", "navigation.sections"], "search": "../../../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../../../assets/javascripts/bundle.92b07e13.min.js"></script>
      
    
  </body>
</html>